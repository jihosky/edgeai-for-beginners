<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "258ecb2013d1666fca92cc5ba7e9a4a0",
  "translation_date": "2025-10-30T15:48:18+00:00",
  "source_file": "Module04/07.QualcommQNN.md",
  "language_code": "ja"
}
-->
# セクション7 : Qualcomm QNN (Qualcomm Neural Network) 最適化スイート

## 目次
1. [はじめに](../../../Module04)
2. [Qualcomm QNNとは？](../../../Module04)
3. [インストール](../../../Module04)
4. [クイックスタートガイド](../../../Module04)
5. [例: QNNを使用したモデルの変換と最適化](../../../Module04)
6. [高度な使用法](../../../Module04)
7. [ベストプラクティス](../../../Module04)
8. [トラブルシューティング](../../../Module04)
9. [追加リソース](../../../Module04)

## はじめに

Qualcomm QNN (Qualcomm Neural Network) は、QualcommのAIハードウェアアクセラレータ（Hexagon NPU、Adreno GPU、Kryo CPUなど）の性能を最大限に引き出すために設計された包括的なAI推論フレームワークです。モバイルデバイス、エッジコンピューティングプラットフォーム、自動車システムを対象とする場合でも、QNNはQualcommの専門的なAI処理ユニットを活用して、最大の性能とエネルギー効率を提供します。

## Qualcomm QNNとは？

Qualcomm QNNは、Qualcommの異種コンピューティングアーキテクチャ全体でAIモデルを効率的に展開するための統一されたAI推論フレームワークです。Hexagon NPU（ニューラルプロセッシングユニット）、Adreno GPU、Kryo CPUへのアクセスを統一されたプログラミングインターフェースで提供し、モデルの層や操作に応じて最適な処理ユニットを自動的に選択します。

### 主な特徴

- **異種コンピューティング**: NPU、GPU、CPUへの統一アクセスと自動ワークロード分配
- **ハードウェア対応の最適化**: Qualcomm Snapdragonプラットフォーム向けの特別な最適化
- **量子化サポート**: 高度なINT8、INT16、および混合精度量子化技術
- **モデル変換ツール**: TensorFlow、PyTorch、ONNX、Caffeモデルを直接サポート
- **エッジAIに最適化**: モバイルおよびエッジ展開シナリオ向けに設計され、電力効率に重点

### 利点

- **最大性能**: 専門的なAIハードウェアを活用し、最大15倍の性能向上
- **電力効率**: モバイルおよびバッテリー駆動デバイス向けに最適化されたインテリジェントな電力管理
- **低遅延**: ハードウェア加速推論によるリアルタイムアプリケーション向けの最小オーバーヘッド
- **スケーラブルな展開**: Qualcommのエコシステム全体でスマートフォンから自動車プラットフォームまで対応
- **実用性**: 数百万台のデバイスで使用されている実績のあるフレームワーク

## インストール

### 前提条件

- Qualcomm QNN SDK（Qualcommへの登録が必要）
- Python 3.7以上
- 対応するQualcommハードウェアまたはシミュレーター
- Android NDK（モバイル展開用）
- LinuxまたはWindowsの開発環境

### QNN SDKのセットアップ

1. **登録とダウンロード**: Qualcomm Developer Networkにアクセスして登録し、QNN SDKをダウンロード
2. **SDKの解凍**: QNN SDKを開発ディレクトリに展開
3. **環境変数の設定**: QNNツールとライブラリのパスを設定

```bash
# Set QNN environment variables
export QNN_SDK_ROOT=/path/to/qnn-sdk
export PATH=$QNN_SDK_ROOT/bin:$PATH
export LD_LIBRARY_PATH=$QNN_SDK_ROOT/lib:$LD_LIBRARY_PATH
```

### Python環境のセットアップ

仮想環境を作成してアクティブ化:

```bash
# Create virtual environment
python -m venv qnn-env

# Activate virtual environment
# On Windows:
qnn-env\Scripts\activate
# On Linux:
source qnn-env/bin/activate
```

必要なPythonパッケージをインストール:

```bash
pip install numpy tensorflow torch onnx
```

### インストールの確認

```bash
# Check QNN tools availability
qnn-model-lib-generator --help
qnn-context-binary-generator --help
qnn-net-run --help
```

成功すると、各QNNツールのヘルプ情報が表示されます。

## クイックスタートガイド

### 初めてのモデル変換

簡単なPyTorchモデルをQualcommハードウェアで動作するように変換してみましょう:

```python
import torch
import torch.nn as nn
import numpy as np

# Define a simple model
class SimpleModel(nn.Module):
    def __init__(self):
        super(SimpleModel, self).__init__()
        self.conv1 = nn.Conv2d(3, 32, 3, padding=1)
        self.relu = nn.ReLU()
        self.conv2 = nn.Conv2d(32, 64, 3, padding=1)
        self.pool = nn.AdaptiveAvgPool2d((1, 1))
        self.fc = nn.Linear(64, 10)
    
    def forward(self, x):
        x = self.relu(self.conv1(x))
        x = self.relu(self.conv2(x))
        x = self.pool(x)
        x = x.view(x.size(0), -1)
        x = self.fc(x)
        return x

# Create and export model
model = SimpleModel()
model.eval()

# Create dummy input for tracing
dummy_input = torch.randn(1, 3, 224, 224)

# Export to ONNX
torch.onnx.export(
    model,
    dummy_input,
    "simple_model.onnx",
    export_params=True,
    opset_version=11,
    do_constant_folding=True,
    input_names=['input'],
    output_names=['output'],
    dynamic_axes={'input': {0: 'batch_size'},
                  'output': {0: 'batch_size'}}
)
```

### ONNXをQNN形式に変換

```bash
# Convert ONNX model to QNN model library
qnn-onnx-converter \
    --input_network simple_model.onnx \
    --output_path simple_model.cpp \
    --input_dim input 1,3,224,224 \
    --quantization_overrides quantization_config.json
```

### QNNモデルライブラリの生成

```bash
# Compile model library
qnn-model-lib-generator \
    -c simple_model.cpp \
    -b simple_model.bin \
    -t x86_64-linux-clang \
    -l simple_model \
    -o simple_model_qnn.so
```

### このプロセスの概要

最適化ワークフローは、元のモデルをONNX形式に変換し、ONNXをQNN中間表現に変換し、ハードウェア固有の最適化を適用し、展開用のコンパイル済みモデルライブラリを生成するプロセスです。

### 主なパラメータの説明

- `--input_network`: ソースONNXモデルファイル
- `--output_path`: 生成されたC++ソースファイル
- `--input_dim`: 最適化のための入力テンソルの次元
- `--quantization_overrides`: カスタム量子化設定
- `-t x86_64-linux-clang`: ターゲットアーキテクチャとコンパイラ

## 例: QNNを使用したモデルの変換と最適化

### ステップ1: 量子化を使用した高度なモデル変換

カスタム量子化を適用する方法はこちら:

```json
// quantization_config.json
{
  "activation_encodings": {
    "conv1/Relu:0": {
      "bitwidth": 8,
      "max": 6.0,
      "min": 0.0,
      "scale": 0.023529,
      "offset": 0
    }
  },
  "param_encodings": {
    "conv1.weight": {
      "bitwidth": 8,
      "max": 2.5,
      "min": -2.5,
      "scale": 0.019608,
      "offset": 127
    }
  },
  "activation_bitwidth": 8,
  "param_bitwidth": 8,
  "bias_bitwidth": 32
}
```

カスタム量子化で変換:

```bash
qnn-onnx-converter \
    --input_network model.onnx \
    --output_path model_quantized.cpp \
    --input_dim input 1,3,224,224 \
    --quantization_overrides quantization_config.json \
    --target_device hexagon \
    --optimization_level high
```

### ステップ2: マルチバックエンド最適化

NPU、GPU、CPU間で異種実行を設定:

```bash
# Generate model library with multiple backend support
qnn-model-lib-generator \
    -c model_quantized.cpp \
    -b model_quantized.bin \
    -t aarch64-android \
    -l model_optimized \
    -o model_optimized.so \
    --target_backends htp,gpu,cpu
```

### ステップ3: 展開用コンテキストバイナリの作成

```bash
# Generate optimized context binary
qnn-context-binary-generator \
    --model model_optimized.so \
    --backend libQnnHtp.so \
    --output_dir ./context_binaries \
    --input_list input_data.txt \
    --optimization_level high
```

### ステップ4: QNNランタイムでの推論

```python
import ctypes
import numpy as np

# Load QNN library
qnn_lib = ctypes.CDLL('./libQnn.so')

class QNNInference:
    def __init__(self, model_path, backend='htp'):
        self.model_path = model_path
        self.backend = backend
        self.context = None
        self._initialize()
    
    def _initialize(self):
        # Initialize QNN runtime
        # Load model and create inference context
        pass
    
    def preprocess_input(self, data):
        # Quantize input data if needed
        if self.is_quantized:
            # Apply quantization parameters
            scale = self.input_scale
            offset = self.input_offset
            quantized = np.clip(
                np.round(data / scale + offset), 
                0, 255
            ).astype(np.uint8)
            return quantized
        return data.astype(np.float32)
    
    def inference(self, input_data):
        # Preprocess input
        processed_input = self.preprocess_input(input_data)
        
        # Run inference on Qualcomm hardware
        # This would call into QNN C++ API
        output = self._run_inference(processed_input)
        
        # Postprocess output
        return self.postprocess_output(output)
    
    def postprocess_output(self, output):
        # Dequantize output if needed
        if self.is_quantized:
            scale = self.output_scale
            offset = self.output_offset
            dequantized = (output.astype(np.float32) - offset) * scale
            return dequantized
        return output

# Usage
inference_engine = QNNInference("model_optimized.so", backend="htp")
result = inference_engine.inference(input_tensor)
print(f"Inference result: {result}")
```

### 出力構造

最適化後、展開ディレクトリには以下が含まれます:

```
qnn_model/
├── model_optimized.so          # Compiled model library
├── context_binaries/           # Pre-compiled contexts
│   ├── htp_context.bin        # NPU context
│   ├── gpu_context.bin        # GPU context
│   └── cpu_context.bin        # CPU context
├── quantization_config.json   # Quantization parameters
└── input_specs.json          # Input/output specifications
```

## 高度な使用法

### カスタムバックエンド設定

特定のバックエンド最適化を設定:

```json
// backend_config.json
{
  "htp_config": {
    "device_id": 0,
    "performance_mode": "high_performance",
    "precision_mode": "int8",
    "vtcm_mb": 8,
    "enable_dma": true
  },
  "gpu_config": {
    "device_id": 0,
    "performance_mode": "sustained_high_performance",
    "precision_mode": "fp16",
    "enable_transform_optimization": true
  },
  "cpu_config": {
    "num_threads": 4,
    "performance_mode": "balanced",
    "enable_fast_math": true
  }
}
```

### 動的量子化

精度を向上させるために実行時に量子化を適用:

```python
class DynamicQuantization:
    def __init__(self, model_path):
        self.model_path = model_path
        self.calibration_data = []
    
    def collect_statistics(self, calibration_dataset):
        """Collect activation statistics for quantization"""
        for data in calibration_dataset:
            # Run inference and collect activation ranges
            activations = self.forward_hooks(data)
            self.calibration_data.append(activations)
    
    def compute_quantization_params(self):
        """Compute optimal quantization parameters"""
        params = {}
        for layer_name, activations in self.calibration_data:
            min_val = np.min(activations)
            max_val = np.max(activations)
            
            # Compute scale and offset for INT8 quantization
            scale = (max_val - min_val) / 255.0
            offset = -min_val / scale
            
            params[layer_name] = {
                "scale": scale,
                "offset": int(offset),
                "min": min_val,
                "max": max_val
            }
        
        return params
    
    def apply_quantization(self, quantization_params):
        """Apply computed quantization parameters"""
        config = {
            "activation_encodings": {},
            "param_encodings": {}
        }
        
        for layer, params in quantization_params.items():
            config["activation_encodings"][layer] = {
                "bitwidth": 8,
                "scale": params["scale"],
                "offset": params["offset"],
                "min": params["min"],
                "max": params["max"]
            }
        
        return config
```

### パフォーマンスプロファイリング

異なるバックエンド間でのパフォーマンスを監視:

```python
import time
import psutil

class QNNProfiler:
    def __init__(self):
        self.metrics = {}
    
    def profile_inference(self, inference_func, input_data, num_runs=100):
        """Profile inference performance"""
        latencies = []
        cpu_usage = []
        memory_usage = []
        
        for i in range(num_runs):
            # Monitor system resources
            process = psutil.Process()
            cpu_before = process.cpu_percent()
            memory_before = process.memory_info().rss
            
            # Measure inference time
            start_time = time.perf_counter()
            result = inference_func(input_data)
            end_time = time.perf_counter()
            
            latency = (end_time - start_time) * 1000  # Convert to ms
            latencies.append(latency)
            
            # Collect resource usage
            cpu_after = process.cpu_percent()
            memory_after = process.memory_info().rss
            
            cpu_usage.append(cpu_after - cpu_before)
            memory_usage.append(memory_after - memory_before)
        
        return {
            "avg_latency_ms": np.mean(latencies),
            "p95_latency_ms": np.percentile(latencies, 95),
            "p99_latency_ms": np.percentile(latencies, 99),
            "throughput_fps": 1000 / np.mean(latencies),
            "avg_cpu_usage": np.mean(cpu_usage),
            "avg_memory_delta_mb": np.mean(memory_usage) / (1024 * 1024)
        }

# Usage
profiler = QNNProfiler()
htp_metrics = profiler.profile_inference(htp_inference, test_data)
gpu_metrics = profiler.profile_inference(gpu_inference, test_data)
cpu_metrics = profiler.profile_inference(cpu_inference, test_data)

print("HTP Performance:", htp_metrics)
print("GPU Performance:", gpu_metrics)
print("CPU Performance:", cpu_metrics)
```

### 自動バックエンド選択

モデル特性に基づいてインテリジェントなバックエンド選択を実装:

```python
class BackendSelector:
    def __init__(self):
        self.backend_capabilities = {
            "htp": {
                "supported_ops": ["Conv2d", "Dense", "BatchNorm", "ReLU"],
                "max_tensor_size": 8 * 1024 * 1024,  # 8MB
                "preferred_precision": "int8",
                "power_efficiency": 0.9
            },
            "gpu": {
                "supported_ops": ["Conv2d", "Dense", "ReLU", "Softmax"],
                "max_tensor_size": 64 * 1024 * 1024,  # 64MB
                "preferred_precision": "fp16",
                "power_efficiency": 0.6
            },
            "cpu": {
                "supported_ops": ["*"],  # All operations
                "max_tensor_size": 512 * 1024 * 1024,  # 512MB
                "preferred_precision": "fp32",
                "power_efficiency": 0.4
            }
        }
    
    def select_optimal_backend(self, model_info, constraints):
        """Select optimal backend based on model and constraints"""
        scores = {}
        
        for backend, caps in self.backend_capabilities.items():
            score = 0
            
            # Check operation support
            if all(op in caps["supported_ops"] or "*" in caps["supported_ops"] 
                   for op in model_info["operations"]):
                score += 30
            
            # Check tensor size compatibility
            if model_info["max_tensor_size"] <= caps["max_tensor_size"]:
                score += 25
            
            # Power efficiency consideration
            if constraints.get("power_critical", False):
                score += caps["power_efficiency"] * 25
            
            # Performance preference
            if constraints.get("performance_critical", False):
                if backend == "htp":
                    score += 20
            
            scores[backend] = score
        
        return max(scores, key=scores.get)

# Usage
selector = BackendSelector()
model_info = {
    "operations": ["Conv2d", "ReLU", "Dense"],
    "max_tensor_size": 4 * 1024 * 1024,
    "precision": "int8"
}
constraints = {
    "power_critical": True,
    "performance_critical": True
}

optimal_backend = selector.select_optimal_backend(model_info, constraints)
print(f"Recommended backend: {optimal_backend}")
```

## ベストプラクティス

### 1. モデルアーキテクチャの最適化
- **レイヤー融合**: Conv+BatchNorm+ReLUのような操作を統合してNPUの利用を向上
- **深層分離畳み込み**: モバイル展開では標準畳み込みよりもこれを推奨
- **量子化に適した設計**: ReLU活性化を使用し、量子化に適さない操作を避ける

### 2. 量子化戦略
- **ポストトレーニング量子化**: 迅速な展開にはこれを開始点とする
- **キャリブレーションデータセット**: すべての入力バリエーションをカバーする代表的なデータを使用
- **混合精度**: ほとんどの層でINT8を使用し、重要な層は高精度を維持

### 3. バックエンド選択ガイドライン
- **NPU (HTP)**: CNNワークロード、量子化モデル、電力感度の高いアプリケーションに最適
- **GPU**: 計算集約型操作、大型モデル、FP16精度に最適
- **CPU**: サポートされていない操作やデバッグのフォールバック

### 4. パフォーマンス最適化
- **バッチサイズ**: リアルタイムアプリケーションにはバッチサイズ1を使用、大量処理には大きなバッチを使用
- **入力前処理**: データコピーと変換のオーバーヘッドを最小化
- **コンテキスト再利用**: 実行時のコンパイルオーバーヘッドを避けるためにコンテキストを事前コンパイル

### 5. メモリ管理
- **テンソル割り当て**: 実行時のオーバーヘッドを避けるために静的割り当てを使用
- **メモリプール**: 頻繁に割り当てられるテンソル用にカスタムメモリプールを実装
- **バッファ再利用**: 推論呼び出し間で入力/出力バッファを再利用

### 6. 電力最適化
- **パフォーマンスモード**: 熱制約に基づいて適切なパフォーマンスモードを使用
- **動的周波数スケーリング**: ワークロードに基づいてシステムが周波数をスケーリングできるようにする
- **アイドル状態管理**: 使用していないときにリソースを適切に解放

## トラブルシューティング

### よくある問題

#### 1. SDKインストールの問題
```bash
# Verify QNN SDK installation
echo $QNN_SDK_ROOT
ls $QNN_SDK_ROOT/bin/qnn-*

# Check library dependencies
ldd $QNN_SDK_ROOT/lib/libQnn.so
```

#### 2. モデル変換エラー
```bash
# Enable verbose logging
qnn-onnx-converter \
    --input_network model.onnx \
    --output_path model.cpp \
    --debug \
    --log_level verbose
```

#### 3. 量子化の問題
```python
# Validate quantization parameters
def validate_quantization_range(data, scale, offset, bitwidth=8):
    quantized = np.clip(
        np.round(data / scale + offset), 
        0, (2**bitwidth) - 1
    )
    dequantized = (quantized - offset) * scale
    mse = np.mean((data - dequantized) ** 2)
    print(f"Quantization MSE: {mse}")
    return mse < threshold
```

#### 4. パフォーマンスの問題
```bash
# Check hardware utilization
adb shell cat /sys/class/devfreq/soc:qcom,cpu*-cpu-ddr-latfloor/cur_freq
adb shell cat /sys/class/kgsl/kgsl-3d0/gpuclk

# Monitor NPU usage
adb shell cat /sys/kernel/debug/msm_vidc/load
```

#### 5. メモリの問題
```python
# Monitor memory usage
import tracemalloc

tracemalloc.start()
# Run inference
result = inference_engine.inference(input_data)
current, peak = tracemalloc.get_traced_memory()
print(f"Current memory usage: {current / 1024 / 1024:.1f} MB")
print(f"Peak memory usage: {peak / 1024 / 1024:.1f} MB")
tracemalloc.stop()
```

#### 6. バックエンドの互換性
```python
# Check backend availability
def check_backend_support():
    try:
        # Load backend library
        htp_lib = ctypes.CDLL('./libQnnHtp.so')
        print("HTP backend available")
    except OSError:
        print("HTP backend not available")
    
    try:
        gpu_lib = ctypes.CDLL('./libQnnGpu.so')
        print("GPU backend available")
    except OSError:
        print("GPU backend not available")
```

### パフォーマンスデバッグ

```python
# Create performance analysis tool
class QNNDebugger:
    def __init__(self, model_path):
        self.model_path = model_path
        self.layer_timings = {}
    
    def profile_layers(self, input_data):
        """Profile individual layer performance"""
        # This would require integration with QNN profiling APIs
        for layer_name in self.get_layer_names():
            start = time.perf_counter()
            # Execute layer
            end = time.perf_counter()
            self.layer_timings[layer_name] = (end - start) * 1000
    
    def analyze_bottlenecks(self):
        """Identify performance bottlenecks"""
        sorted_layers = sorted(
            self.layer_timings.items(), 
            key=lambda x: x[1], 
            reverse=True
        )
        
        print("Top 5 slowest layers:")
        for layer, time_ms in sorted_layers[:5]:
            print(f"  {layer}: {time_ms:.2f} ms")
    
    def suggest_optimizations(self):
        """Suggest optimization strategies"""
        suggestions = []
        
        for layer, time_ms in self.layer_timings.items():
            if time_ms > 10:  # Layer takes more than 10ms
                if "conv" in layer.lower():
                    suggestions.append(f"Consider depthwise separable conv for {layer}")
                elif "dense" in layer.lower():
                    suggestions.append(f"Consider quantization for {layer}")
        
        return suggestions
```

### サポートの取得

- **Qualcomm Developer Network**: [developer.qualcomm.com](https://developer.qualcomm.com/)
- **QNNドキュメント**: SDKパッケージに含まれています
- **コミュニティフォーラム**: [developer.qualcomm.com/forums](https://developer.qualcomm.com/forums)
- **技術サポート**: Qualcomm開発者ポータルを通じて

## 追加リソース

### 公式リンク
- **Qualcomm AI Hub**: [aihub.qualcomm.com](https://aihub.qualcomm.com/)
- **Snapdragonプラットフォーム**: [qualcomm.com/products/mobile/snapdragon](https://www.qualcomm.com/products/mobile/snapdragon)
- **開発者ポータル**: [developer.qualcomm.com/software/qualcomm-neural-processing-sdk](https://developer.qualcomm.com/software/qualcomm-neural-processing-sdk)
- **AIエンジン**: [qualcomm.com/news/onq/2019/06/qualcomm-ai-engine-direct](https://www.qualcomm.com/news/onq/2019/06/qualcomm-ai-engine-direct)

### 学習リソース
- **入門ガイド**: QNN SDKドキュメントにて利用可能
- **モデルズー**: [aihub.qualcomm.com/models](https://aihub.qualcomm.com/models)
- **最適化ガイド**: SDKドキュメントには包括的な最適化ガイドラインが含まれています
- **ビデオチュートリアル**: [Qualcomm Developer YouTube Channel](https://www.youtube.com/c/QualcommDeveloperNetwork)

### 統合ツール
- **SNPE (Legacy)**: [developer.qualcomm.com/docs/snpe](https://developer.qualcomm.com/docs/snpe/overview.html)
- **AI Hub**: Qualcommハードウェア向けに最適化されたモデル
- **Android Neural Networks API**: Android NNAPIとの統合
- **TensorFlow Lite Delegate**: TFLite向けQualcommデリゲート

### パフォーマンスベンチマーク
- **MLPerf Mobile**: [mlcommons.org/en/inference-mobile-21](https://mlcommons.org/en/inference-mobile-21/)
- **AI Benchmark**: [ai-benchmark.com/ranking](https://ai-benchmark.com/ranking.html)
- **Qualcomm AI Research**: [qualcomm.com/research/artificial-intelligence](https://www.qualcomm.com/research/artificial-intelligence)

### コミュニティ例
- **サンプルアプリケーション**: QNN SDKの例のディレクトリで利用可能
- **GitHubリポジトリ**: コミュニティが提供する例やツール
- **技術ブログ**: [Qualcomm Developer Blog](https://developer.qualcomm.com/blog)

### 関連ツール
- **Qualcomm AI Model Efficiency Toolkit (AIMET)**: [github.com/quic/aimet](https://github.com/quic/aimet) - 高度な量子化と圧縮技術
- **TensorFlow Lite**: [tensorflow.org/lite](https://www.tensorflow.org/lite) - 比較およびフォールバック展開用
- **ONNX Runtime**: [onnxruntime.ai](https://onnxruntime.ai/) - クロスプラットフォーム推論エンジン

### ハードウェア仕様
- **Hexagon NPU**: [developer.qualcomm.com/hardware/hexagon-dsp](https://developer.qualcomm.com/hardware/hexagon-dsp)
- **Adreno GPU**: [developer.qualcomm.com/hardware/adreno-gpu](https://developer.qualcomm.com/hardware/adreno-gpu)
- **Snapdragonプラットフォーム**: [qualcomm.com/products/mobile/snapdragon](https://www.qualcomm.com/products/mobile/snapdragon)

## ➡️ 次のステップ

[モジュール5: SLMOpsと本番展開](../Module05/README.md) を探索し、小型言語モデルのライフサイクル管理の運用面について学びましょう。

---

**免責事項**:  
この文書はAI翻訳サービス[Co-op Translator](https://github.com/Azure/co-op-translator)を使用して翻訳されています。正確性を追求しておりますが、自動翻訳には誤りや不正確な部分が含まれる可能性があります。元の言語で記載された文書を正式な情報源としてご参照ください。重要な情報については、専門の人間による翻訳を推奨します。この翻訳の使用に起因する誤解や誤解釈について、当社は一切の責任を負いません。