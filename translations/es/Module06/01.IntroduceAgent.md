<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "44bc28c27b993c5fb988791b7a115705",
  "translation_date": "2025-10-30T10:36:33+00:00",
  "source_file": "Module06/01.IntroduceAgent.md",
  "language_code": "es"
}
-->
# Agentes de IA y Modelos de Lenguaje Peque√±os: Una Gu√≠a Completa

## Introducci√≥n

En este tutorial, exploraremos los Agentes de IA y los Modelos de Lenguaje Peque√±os (SLMs) junto con sus estrategias avanzadas de implementaci√≥n para entornos de computaci√≥n en el borde. Cubriremos los conceptos fundamentales de la IA agentica, t√©cnicas de optimizaci√≥n de SLM, estrategias pr√°cticas de despliegue para dispositivos con recursos limitados y el Microsoft Agent Framework para construir sistemas de agentes listos para producci√≥n.

El panorama de la inteligencia artificial est√° experimentando un cambio paradigm√°tico en 2025. Mientras que 2023 fue el a√±o de los chatbots y 2024 vio un auge en los copilotos, 2025 pertenece a los agentes de IA: sistemas inteligentes que piensan, razonan, planifican, utilizan herramientas y ejecutan tareas con m√≠nima intervenci√≥n humana, impulsados cada vez m√°s por Modelos de Lenguaje Peque√±os eficientes. Microsoft Agent Framework surge como una soluci√≥n l√≠der para construir estos sistemas inteligentes con capacidades offline basadas en el borde.

## Objetivos de Aprendizaje

Al final de este tutorial, ser√°s capaz de:

- ü§ñ Comprender los conceptos fundamentales de los agentes de IA y los sistemas agenticos
- üî¨ Identificar las ventajas de los Modelos de Lenguaje Peque√±os sobre los Modelos de Lenguaje Grandes en aplicaciones agenticas
- üöÄ Aprender estrategias avanzadas de despliegue de SLM para entornos de computaci√≥n en el borde
- üì± Implementar agentes pr√°cticos impulsados por SLM para aplicaciones del mundo real
- üèóÔ∏è Construir agentes listos para producci√≥n utilizando Microsoft Agent Framework
- üåê Desplegar agentes offline basados en el borde con integraci√≥n local de LLM y SLM
- üîß Integrar Microsoft Agent Framework con Foundry Local para despliegue en el borde

## Comprendiendo los Agentes de IA: Fundamentos y Clasificaciones

### Definici√≥n y Conceptos Clave

Un agente de inteligencia artificial (IA) se refiere a un sistema o programa capaz de realizar tareas de manera aut√≥noma en nombre de un usuario u otro sistema, dise√±ando su flujo de trabajo y utilizando herramientas disponibles. A diferencia de la IA tradicional que solo responde a tus preguntas, un agente puede actuar independientemente para alcanzar objetivos.

### Marco de Clasificaci√≥n de Agentes

Comprender los l√≠mites de los agentes ayuda a seleccionar los tipos de agentes apropiados para diferentes escenarios de computaci√≥n:

- **üî¨ Agentes de Reflexi√≥n Simple**: Sistemas basados en reglas que responden a percepciones inmediatas (termostatos, automatizaci√≥n b√°sica)
- **üì± Agentes Basados en Modelos**: Sistemas que mantienen estado interno y memoria (aspiradoras robot, sistemas de navegaci√≥n)
- **‚öñÔ∏è Agentes Basados en Objetivos**: Sistemas que planifican y ejecutan secuencias para alcanzar objetivos (planificadores de rutas, programadores de tareas)
- **üß† Agentes de Aprendizaje**: Sistemas adaptativos que mejoran su rendimiento con el tiempo (sistemas de recomendaci√≥n, asistentes personalizados)

### Ventajas Clave de los Agentes de IA

Los agentes de IA ofrecen varias ventajas fundamentales que los hacen ideales para aplicaciones de computaci√≥n en el borde:

**Autonom√≠a Operativa**: Los agentes proporcionan ejecuci√≥n independiente de tareas sin supervisi√≥n humana constante, lo que los hace ideales para aplicaciones en tiempo real. Requieren m√≠nima supervisi√≥n mientras mantienen un comportamiento adaptativo, permitiendo su despliegue en dispositivos con recursos limitados y reduciendo la sobrecarga operativa.

**Flexibilidad de Despliegue**: Estos sistemas permiten capacidades de IA en el dispositivo sin necesidad de conectividad a internet, mejoran la privacidad y seguridad mediante procesamiento local, pueden personalizarse para aplicaciones espec√≠ficas de dominio y son adecuados para diversos entornos de computaci√≥n en el borde.

**Eficiencia de Costos**: Los sistemas de agentes ofrecen un despliegue rentable en comparaci√≥n con soluciones basadas en la nube, con costos operativos reducidos y menores requisitos de ancho de banda para aplicaciones en el borde.

## Estrategias Avanzadas para Modelos de Lenguaje Peque√±os

### Fundamentos de SLM (Modelo de Lenguaje Peque√±o)

Un Modelo de Lenguaje Peque√±o (SLM) es un modelo de lenguaje que puede ajustarse a un dispositivo electr√≥nico de consumo com√∫n y realizar inferencias con una latencia suficientemente baja para ser pr√°ctico al atender solicitudes agenticas de un usuario. En t√©rminos pr√°cticos, los SLM suelen ser modelos con menos de 10 mil millones de par√°metros.

**Caracter√≠sticas de Descubrimiento de Formato**: Los SLM ofrecen soporte avanzado para varios niveles de cuantizaci√≥n, compatibilidad multiplataforma, optimizaci√≥n de rendimiento en tiempo real y capacidades de despliegue en el borde. Los usuarios pueden acceder a una mayor privacidad mediante procesamiento local y soporte WebGPU para despliegue en navegadores.

**Colecciones de Niveles de Cuantizaci√≥n**: Los formatos populares de SLM incluyen Q4_K_M para compresi√≥n equilibrada en aplicaciones m√≥viles, la serie Q5_K_S para despliegue en el borde enfocado en calidad, Q8_0 para precisi√≥n casi original en dispositivos potentes del borde y formatos experimentales como Q2_K para escenarios de recursos ultra bajos.

### GGUF (Formato Universal GGML General) para Despliegue de SLM

GGUF sirve como el formato principal para desplegar SLM cuantificados en CPU y dispositivos del borde, espec√≠ficamente optimizado para aplicaciones agenticas:

**Caracter√≠sticas Optimizadas para Agentes**: El formato proporciona recursos completos para conversi√≥n y despliegue de SLM con soporte mejorado para llamadas a herramientas, generaci√≥n de salidas estructuradas y conversaciones de m√∫ltiples turnos. La compatibilidad multiplataforma asegura un comportamiento consistente de los agentes en diferentes dispositivos del borde.

**Optimizaci√≥n de Rendimiento**: GGUF permite un uso eficiente de memoria para flujos de trabajo de agentes, soporta carga din√°mica de modelos para sistemas de m√∫ltiples agentes y proporciona inferencias optimizadas para interacciones en tiempo real con agentes.

### Marcos de SLM Optimizados para el Borde

#### Optimizaci√≥n de Llama.cpp para Agentes

Llama.cpp proporciona t√©cnicas de cuantizaci√≥n de vanguardia espec√≠ficamente optimizadas para el despliegue agentico de SLM:

**Cuantizaci√≥n Espec√≠fica para Agentes**: El marco soporta Q4_0 (√≥ptimo para despliegue de agentes m√≥viles con reducci√≥n de tama√±o del 75%), Q5_1 (calidad-compresi√≥n equilibrada para agentes de inferencia en el borde) y Q8_0 (calidad casi original para sistemas de agentes en producci√≥n). Los formatos avanzados permiten agentes ultra comprimidos para escenarios extremos en el borde.

**Beneficios de Implementaci√≥n**: La inferencia optimizada para CPU con aceleraci√≥n SIMD proporciona una ejecuci√≥n eficiente en memoria para agentes. La compatibilidad multiplataforma en arquitecturas x86, ARM y Apple Silicon permite capacidades universales de despliegue de agentes.

#### Marco Apple MLX para Agentes SLM

Apple MLX proporciona optimizaci√≥n nativa espec√≠ficamente dise√±ada para agentes impulsados por SLM en dispositivos Apple Silicon:

**Optimizaci√≥n de Agentes en Apple Silicon**: El marco utiliza arquitectura de memoria unificada con integraci√≥n de Metal Performance Shaders, precisi√≥n mixta autom√°tica para inferencia de agentes y ancho de banda de memoria optimizado para sistemas de m√∫ltiples agentes. Los agentes SLM muestran un rendimiento excepcional en chips de la serie M.

**Caracter√≠sticas de Desarrollo**: Soporte de API en Python y Swift con optimizaciones espec√≠ficas para agentes, diferenciaci√≥n autom√°tica para aprendizaje de agentes e integraci√≥n fluida con herramientas de desarrollo de Apple proporcionan entornos completos de desarrollo de agentes.

#### ONNX Runtime para Agentes SLM Multiplataforma

ONNX Runtime proporciona un motor de inferencia universal que permite a los agentes SLM ejecutarse de manera consistente en diversas plataformas de hardware y sistemas operativos:

**Despliegue Universal**: ONNX Runtime asegura un comportamiento consistente de los agentes SLM en plataformas Windows, Linux, macOS, iOS y Android. Esta compatibilidad multiplataforma permite a los desarrolladores escribir una vez y desplegar en todas partes, reduciendo significativamente la sobrecarga de desarrollo y mantenimiento para aplicaciones multiplataforma.

**Opciones de Aceleraci√≥n de Hardware**: El marco proporciona proveedores de ejecuci√≥n optimizados para diversas configuraciones de hardware, incluyendo CPU (Intel, AMD, ARM), GPU (NVIDIA CUDA, AMD ROCm) y aceleradores especializados (Intel VPU, Qualcomm NPU). Los agentes SLM pueden aprovechar autom√°ticamente el mejor hardware disponible sin cambios en el c√≥digo.

**Caracter√≠sticas Listas para Producci√≥n**: ONNX Runtime ofrece caracter√≠sticas de nivel empresarial esenciales para el despliegue de agentes en producci√≥n, incluyendo optimizaci√≥n de gr√°ficos para inferencias m√°s r√°pidas, gesti√≥n de memoria para entornos con recursos limitados y herramientas completas de perfilado para an√°lisis de rendimiento. El marco soporta APIs en Python y C++ para una integraci√≥n flexible.

## SLM vs LLM en Sistemas Agenticos: Comparaci√≥n Avanzada

### Ventajas de SLM en Aplicaciones de Agentes

**Eficiencia Operativa**: Los SLM proporcionan una reducci√≥n de costos de 10-30√ó en comparaci√≥n con los LLM para tareas de agentes, permitiendo respuestas agenticas en tiempo real a gran escala. Ofrecen tiempos de inferencia m√°s r√°pidos debido a la menor complejidad computacional, lo que los hace ideales para aplicaciones interactivas de agentes.

**Capacidades de Despliegue en el Borde**: Los SLM permiten la ejecuci√≥n de agentes en el dispositivo sin dependencia de internet, mejoran la privacidad mediante procesamiento local y personalizaci√≥n para aplicaciones espec√≠ficas de dominio adecuadas para diversos entornos de computaci√≥n en el borde.

**Optimizaci√≥n Espec√≠fica para Agentes**: Los SLM sobresalen en llamadas a herramientas, generaci√≥n de salidas estructuradas y flujos de trabajo de toma de decisiones rutinarias que comprenden el 70-80% de las tareas t√≠picas de agentes.

### Cu√°ndo Usar SLM vs LLM en Sistemas de Agentes

**Perfecto para SLMs**:
- **Tareas repetitivas de agentes**: Entrada de datos, llenado de formularios, llamadas rutinarias a API
- **Integraci√≥n de herramientas**: Consultas a bases de datos, operaciones de archivos, interacciones con sistemas
- **Flujos de trabajo estructurados**: Seguir procesos predefinidos de agentes
- **Agentes espec√≠ficos de dominio**: Atenci√≥n al cliente, programaci√≥n, an√°lisis b√°sico
- **Procesamiento local**: Operaciones de agentes sensibles a la privacidad

**Mejor para LLMs**:
- **Razonamiento complejo**: Resoluci√≥n de problemas novedosos, planificaci√≥n estrat√©gica
- **Conversaciones abiertas**: Chat general, discusiones creativas
- **Tareas de conocimiento amplio**: Investigaci√≥n que requiere vasto conocimiento general
- **Situaciones novedosas**: Manejo de escenarios completamente nuevos para agentes

### Arquitectura H√≠brida de Agentes

El enfoque √≥ptimo combina SLMs y LLMs en sistemas agenticos heterog√©neos:

**Orquestaci√≥n Inteligente de Agentes**:
1. **SLM como primario**: Manejar el 70-80% de tareas rutinarias de agentes localmente
2. **LLM cuando sea necesario**: Redirigir consultas complejas a modelos m√°s grandes basados en la nube
3. **SLMs especializados**: Diferentes modelos peque√±os para diferentes dominios de agentes
4. **Optimizaci√≥n de costos**: Minimizar llamadas costosas a LLM mediante enrutamiento inteligente

## Estrategias de Despliegue de Agentes SLM en Producci√≥n

### Foundry Local: Runtime de IA en el Borde de Nivel Empresarial

Foundry Local (https://github.com/microsoft/foundry-local) sirve como la soluci√≥n insignia de Microsoft para desplegar Modelos de Lenguaje Peque√±os en entornos de borde de producci√≥n. Proporciona un entorno de runtime completo dise√±ado espec√≠ficamente para agentes impulsados por SLM con caracter√≠sticas de nivel empresarial y capacidades de integraci√≥n sin problemas.

**Arquitectura y Caracter√≠sticas Principales**:
- **API Compatible con OpenAI**: Compatibilidad total con SDK de OpenAI e integraciones de Agent Framework
- **Optimizaci√≥n Autom√°tica de Hardware**: Selecci√≥n inteligente de variantes de modelos seg√∫n el hardware disponible (CUDA GPU, Qualcomm NPU, CPU)
- **Gesti√≥n de Modelos**: Descarga, almacenamiento en cach√© y gesti√≥n del ciclo de vida de modelos SLM automatizados
- **Descubrimiento de Servicios**: Detecci√≥n de servicios sin configuraci√≥n para marcos de agentes
- **Optimizaci√≥n de Recursos**: Gesti√≥n inteligente de memoria y eficiencia energ√©tica para despliegue en el borde

#### Instalaci√≥n y Configuraci√≥n

**Instalaci√≥n Multiplataforma**:
```bash
# Windows (recommended)
winget install Microsoft.FoundryLocal

# macOS
brew tap microsoft/foundrylocal
brew install foundrylocal

# Linux (manual installation)
wget https://github.com/microsoft/foundry-local/releases/latest/download/foundry-local-linux.tar.gz
tar -xzf foundry-local-linux.tar.gz
sudo mv foundry-local /usr/local/bin/
```

**Inicio R√°pido para Desarrollo de Agentes**:
```bash
# Start service with automatic model loading
foundry model run phi-4-mini

# Verify service status and endpoint
foundry service status

# List available models
foundry model ls

# Test API endpoint
curl http://localhost:<port>/v1/models
```

#### Integraci√≥n con Agent Framework

**Integraci√≥n del SDK de Foundry Local**:
```python
from foundry_local import FoundryLocalManager
from microsoft_agent_framework import Agent, Config
import openai

# Initialize Foundry Local with automatic service management
manager = FoundryLocalManager("phi-4-mini")

# Configure OpenAI client for local inference
client = openai.OpenAI(
    base_url=manager.endpoint,
    api_key=manager.api_key  # Auto-generated for local usage
)

# Create agent with Foundry Local backend
agent_config = Config(
    name="production-agent",
    model_provider="foundry-local",
    model_id=manager.get_model_info("phi-4-mini").id,
    endpoint=manager.endpoint,
    api_key=manager.api_key
)

agent = Agent(config=agent_config)
```

**Selecci√≥n Autom√°tica de Modelos y Optimizaci√≥n de Hardware**:
```python
# Foundry Local automatically selects optimal model variant
models_by_use_case = {
    "lightweight_routing": "qwen2.5-0.5b",      # 500MB, ultra-fast
    "general_conversation": "phi-4-mini",       # 2.4GB, balanced
    "complex_reasoning": "phi-4",               # 7GB, high-capability
    "code_assistance": "qwen2.5-coder-0.5b"    # 500MB, code-optimized
}

# Foundry Local handles hardware detection and quantization
for use_case, model_alias in models_by_use_case.items():
    manager = FoundryLocalManager(model_alias)
    print(f"{use_case}: {manager.get_model_info(model_alias).variant_selected}")
    # Output examples:
    # lightweight_routing: qwen2.5-0.5b-instruct-q4_k_m.gguf (CPU optimized)
    # general_conversation: phi-4-mini-instruct-cuda-q5_k_m.gguf (GPU accelerated)
```

#### Patrones de Despliegue en Producci√≥n

**Configuraci√≥n de Producci√≥n para un Solo Agente**:
```python
import asyncio
from foundry_local import FoundryLocalManager
from microsoft_agent_framework import Agent, Config, Tool

class ProductionAgentService:
    def __init__(self, model_alias="phi-4-mini"):
        self.foundry = FoundryLocalManager(model_alias)
        self.agent = self._create_agent()
        
    def _create_agent(self):
        config = Config(
            name="production-customer-service",
            model_provider="foundry-local",
            model_id=self.foundry.get_model_info().id,
            endpoint=self.foundry.endpoint,
            api_key=self.foundry.api_key,
            max_tokens=512,
            temperature=0.1,
            timeout=30.0
        )
        
        agent = Agent(config=config)
        
        # Add production tools
        @agent.tool
        def lookup_customer(customer_id: str) -> dict:
            """Look up customer information from local database."""
            return self.local_db.get_customer(customer_id)
            
        @agent.tool
        def create_ticket(issue: str, priority: str = "medium") -> str:
            """Create a support ticket."""
            ticket_id = self.ticketing_system.create(issue, priority)
            return f"Created ticket {ticket_id}"
            
        return agent
    
    async def process_request(self, user_input: str) -> str:
        """Process user request with error handling and monitoring."""
        try:
            response = await self.agent.chat_async(user_input)
            self.log_interaction(user_input, response, "success")
            return response
        except Exception as e:
            self.log_interaction(user_input, str(e), "error")
            return "I'm experiencing technical difficulties. Please try again."
    
    def health_check(self) -> dict:
        """Check service health for monitoring."""
        return {
            "foundry_status": self.foundry.health_check(),
            "model_loaded": self.foundry.is_model_loaded(),
            "endpoint": self.foundry.endpoint,
            "memory_usage": self.foundry.get_memory_usage()
        }

# Production usage
service = ProductionAgentService("phi-4-mini")
response = await service.process_request("I need help with my order #12345")
```

**Orquestaci√≥n de Producci√≥n para M√∫ltiples Agentes**:
```python
from foundry_local import FoundryLocalManager
from microsoft_agent_framework import AgentOrchestrator, Agent, Config

class MultiAgentProductionSystem:
    def __init__(self):
        self.agents = self._initialize_agents()
        self.orchestrator = AgentOrchestrator(list(self.agents.values()))
        
    def _initialize_agents(self):
        agents = {}
        
        # Lightweight routing agent
        routing_foundry = FoundryLocalManager("qwen2.5-0.5b")
        agents["router"] = Agent(Config(
            name="request-router",
            model_provider="foundry-local",
            endpoint=routing_foundry.endpoint,
            api_key=routing_foundry.api_key,
            role="Route user requests to appropriate specialized agents"
        ))
        
        # Customer service agent
        service_foundry = FoundryLocalManager("phi-4-mini")
        agents["customer_service"] = Agent(Config(
            name="customer-service",
            model_provider="foundry-local",
            endpoint=service_foundry.endpoint,
            api_key=service_foundry.api_key,
            role="Handle customer service inquiries and support requests"
        ))
        
        # Technical support agent
        tech_foundry = FoundryLocalManager("qwen2.5-coder-0.5b")
        agents["technical"] = Agent(Config(
            name="technical-support",
            model_provider="foundry-local",
            endpoint=tech_foundry.endpoint,
            api_key=tech_foundry.api_key,
            role="Provide technical assistance and troubleshooting"
        ))
        
        return agents
    
    async def process_request(self, user_input: str) -> str:
        """Route and process user requests through appropriate agents."""
        # Route request to appropriate agent
        routing_result = await self.agents["router"].chat_async(
            f"Classify this request and route to customer_service or technical: {user_input}"
        )
        
        # Determine target agent based on routing
        target_agent = "customer_service" if "customer" in routing_result.lower() else "technical"
        
        # Process with specialized agent
        response = await self.agents[target_agent].chat_async(user_input)
        
        return response

# Production deployment
system = MultiAgentProductionSystem()
response = await system.process_request("My application keeps crashing")
```

#### Caracter√≠sticas Empresariales y Monitoreo

**Monitoreo de Salud y Observabilidad**:
```python
from foundry_local import FoundryLocalManager
import asyncio
import logging

class FoundryMonitoringService:
    def __init__(self):
        self.managers = {}
        self.metrics = []
        
    def add_model(self, alias: str) -> FoundryLocalManager:
        """Add a model to monitoring."""
        manager = FoundryLocalManager(alias)
        self.managers[alias] = manager
        return manager
    
    async def collect_metrics(self):
        """Collect performance metrics from all Foundry Local instances."""
        metrics = {
            "timestamp": time.time(),
            "models": {}
        }
        
        for alias, manager in self.managers.items():
            try:
                model_metrics = {
                    "status": "healthy" if manager.health_check() else "unhealthy",
                    "memory_usage": manager.get_memory_usage(),
                    "inference_count": manager.get_inference_count(),
                    "average_latency": manager.get_average_latency(),
                    "error_rate": manager.get_error_rate()
                }
                metrics["models"][alias] = model_metrics
            except Exception as e:
                logging.error(f"Failed to collect metrics for {alias}: {e}")
                metrics["models"][alias] = {"status": "error", "error": str(e)}
        
        self.metrics.append(metrics)
        return metrics
    
    def get_health_status(self) -> dict:
        """Get overall system health status."""
        healthy_models = 0
        total_models = len(self.managers)
        
        for alias, manager in self.managers.items():
            if manager.health_check():
                healthy_models += 1
        
        return {
            "overall_status": "healthy" if healthy_models == total_models else "degraded",
            "healthy_models": healthy_models,
            "total_models": total_models,
            "health_percentage": (healthy_models / total_models) * 100 if total_models > 0 else 0
        }

# Production monitoring setup
monitor = FoundryMonitoringService()
monitor.add_model("phi-4-mini")
monitor.add_model("qwen2.5-0.5b")

# Continuous monitoring
async def monitoring_loop():
    while True:
        metrics = await monitor.collect_metrics()
        health = monitor.get_health_status()
        
        if health["health_percentage"] < 100:
            logging.warning(f"System health degraded: {health}")
        
        await asyncio.sleep(30)  # Collect metrics every 30 seconds
```

**Gesti√≥n de Recursos y Escalado Autom√°tico**:
```python
class FoundryResourceManager:
    def __init__(self):
        self.model_instances = {}
        self.resource_limits = {
            "max_memory_gb": 8,
            "max_concurrent_models": 3,
            "cpu_threshold": 80
        }
    
    def auto_scale_models(self, demand_metrics: dict):
        """Automatically scale models based on demand."""
        current_memory = self.get_total_memory_usage()
        
        # Scale down if memory usage is high
        if current_memory > self.resource_limits["max_memory_gb"] * 0.8:
            self.scale_down_idle_models()
        
        # Scale up if demand is high and resources allow
        for model_alias, demand in demand_metrics.items():
            if demand > 0.8 and len(self.model_instances) < self.resource_limits["max_concurrent_models"]:
                self.load_model_instance(model_alias)
    
    def load_model_instance(self, alias: str) -> FoundryLocalManager:
        """Load a new model instance if resources allow."""
        if alias not in self.model_instances:
            try:
                manager = FoundryLocalManager(alias)
                self.model_instances[alias] = manager
                logging.info(f"Loaded model instance: {alias}")
                return manager
            except Exception as e:
                logging.error(f"Failed to load model {alias}: {e}")
                return None
        return self.model_instances[alias]
    
    def scale_down_idle_models(self):
        """Remove idle model instances to free resources."""
        idle_models = []
        
        for alias, manager in self.model_instances.items():
            if manager.get_idle_time() > 300:  # 5 minutes idle
                idle_models.append(alias)
        
        for alias in idle_models:
            self.model_instances[alias].shutdown()
            del self.model_instances[alias]
            logging.info(f"Scaled down idle model: {alias}")
```

#### Configuraci√≥n y Optimizaci√≥n Avanzadas

**Configuraci√≥n Personalizada de Modelos**:
```python
# Advanced Foundry Local configuration for production
from foundry_local import FoundryLocalManager, ModelConfig

# Custom configuration for specific use cases
config = ModelConfig(
    alias="phi-4-mini",
    quantization="Q5_K_M",  # Specific quantization level
    context_length=4096,    # Extended context for complex agents
    batch_size=1,          # Optimized for single-user agents
    threads=4,             # CPU thread optimization
    gpu_layers=32,         # GPU acceleration layers
    memory_lock=True,      # Lock model in memory for consistent performance
    numa=True              # NUMA optimization for multi-socket systems
)

manager = FoundryLocalManager(config=config)
```

**Lista de Verificaci√≥n para Despliegue en Producci√≥n**:

‚úÖ **Configuraci√≥n del Servicio**:
- Configurar alias de modelos apropiados para casos de uso
- Establecer l√≠mites de recursos y umbrales de monitoreo
- Habilitar verificaciones de salud y recopilaci√≥n de m√©tricas
- Configurar reinicio autom√°tico y conmutaci√≥n por error

‚úÖ **Configuraci√≥n de Seguridad**:
- Habilitar acceso API solo local (sin exposici√≥n externa)
- Configurar gesti√≥n adecuada de claves API
- Configurar registro de auditor√≠a para interacciones de agentes
- Implementar limitaci√≥n de tasa para uso en producci√≥n

‚úÖ **Optimizaci√≥n de Rendimiento**:
- Probar el rendimiento del modelo bajo carga esperada
- Configurar niveles de cuantizaci√≥n apropiados
- Establecer estrategias de almacenamiento en cach√© y calentamiento de modelos
- Monitorear patrones de uso de memoria y CPU

‚úÖ **Pruebas de Integraci√≥n**:
- Probar integraci√≥n con el marco de agentes
- Verificar capacidades de operaci√≥n offline
- Probar escenarios de conmutaci√≥n por error y recuperaci√≥n
- Validar flujos de trabajo de agentes de extremo a extremo

### Ollama: Despliegue Simplificado de Agentes SLM

### Ollama: Despliegue de Agentes SLM Enfocado en la Comunidad

Ollama proporciona un enfoque impulsado por la comunidad para el despliegue de agentes SLM con √©nfasis en la simplicidad, un ecosistema extenso de modelos y flujos de trabajo amigables para desarrolladores. Mientras que Foundry Local se centra en caracter√≠sticas de nivel empresarial, Ollama sobresale en prototipado r√°pido, acceso a modelos comunitarios y escenarios de despliegue simplificados.

**Arquitectura y Caracter√≠sticas Principales**:
- **API Compatible con OpenAI**: Compatibilidad completa con API REST para integraci√≥n fluida con marcos de agentes
- **Extensa Biblioteca de Modelos**: Acceso a cientos de modelos contribuidos por la comunidad y oficiales
- **Gesti√≥n Simple de Modelos**: Instalaci√≥n y cambio de modelos con un solo comando
- **Soporte Multiplataforma**: Soporte nativo en Windows, macOS y Linux
- **Optimizaci√≥n de Recursos**: Cuantizaci√≥n autom√°tica y detecci√≥n de hardware

#### Instalaci√≥n y Configuraci√≥n

**Instalaci√≥n Multiplataforma**:
```bash
# Windows
winget install Ollama.Ollama

# macOS
brew install ollama

# Linux
curl -fsSL https://ollama.com/install.sh | sh

# Docker deployment
docker run -d -v ollama:/root/.ollama -p 11434:11434 --name ollama ollama/ollama
```

**Inicio R√°pido para Desarrollo de Agentes**:
```bash
# Start Ollama service
ollama serve

# Pull and run models for agent development
ollama pull phi3.5:3.8b-mini-instruct-q4_K_M    # Microsoft Phi-3.5 Mini
ollama pull qwen2.5:0.5b-instruct-q4_K_M        # Qwen2.5 0.5B
ollama pull llama3.2:1b-instruct-q4_K_M         # Llama 3.2 1B

# Test model availability
ollama list

# Test API endpoint
curl http://localhost:11434/api/generate -d '{
  "model": "phi3.5:3.8b-mini-instruct-q4_K_M",
  "prompt": "Hello, how can I help you today?"
}'
```

#### Integraci√≥n con Agent Framework

**Ollama con Microsoft Agent Framework**:
```python
from microsoft_agent_framework import Agent, Config
import openai
import requests
import json

class OllamaManager:
    def __init__(self, model_name: str, base_url: str = "http://localhost:11434"):
        self.model_name = model_name
        self.base_url = base_url
        self.api_url = f"{base_url}/api"
        self.openai_url = f"{base_url}/v1"
        
    def ensure_model_available(self) -> bool:
        """Ensure the model is pulled and available."""
        try:
            response = requests.post(f"{self.api_url}/pull", 
                json={"name": self.model_name})
            return response.status_code == 200
        except Exception as e:
            print(f"Failed to pull model {self.model_name}: {e}")
            return False
    
    def get_openai_client(self) -> openai.OpenAI:
        """Get OpenAI-compatible client for Ollama."""
        return openai.OpenAI(
            base_url=self.openai_url,
            api_key="ollama",  # Ollama doesn't require real API key
        )
    
    def health_check(self) -> bool:
        """Check if Ollama service is running."""
        try:
            response = requests.get(f"{self.base_url}/api/tags")
            return response.status_code == 200
        except:
            return False

# Initialize Ollama for agent development
ollama_manager = OllamaManager("phi3.5:3.8b-mini-instruct-q4_K_M")
ollama_manager.ensure_model_available()

# Configure agent with Ollama backend
agent_config = Config(
    name="ollama-agent",
    model_provider="ollama",
    model_id="phi3.5:3.8b-mini-instruct-q4_K_M",
    endpoint=ollama_manager.openai_url,
    api_key="ollama"
)

agent = Agent(config=agent_config)
```

**Configuraci√≥n de Agentes Multimodelo con Ollama**:
```python
class OllamaMultiModelManager:
    def __init__(self):
        self.models = {
            "lightweight": "qwen2.5:0.5b-instruct-q4_K_M",      # 350MB
            "balanced": "phi3.5:3.8b-mini-instruct-q4_K_M",     # 2.3GB  
            "capable": "llama3.2:3b-instruct-q4_K_M",           # 1.9GB
            "coding": "codellama:7b-code-q4_K_M"                # 4.1GB
        }
        self.base_url = "http://localhost:11434"
        self.clients = {}
        self._initialize_models()
    
    def _initialize_models(self):
        """Pull all required models and create clients."""
        for category, model_name in self.models.items():
            # Pull model if not available
            self._pull_model(model_name)
            
            # Create OpenAI client for each model
            self.clients[category] = openai.OpenAI(
                base_url=f"{self.base_url}/v1",
                api_key="ollama"
            )
    
    def _pull_model(self, model_name: str):
        """Pull model if not already available."""
        try:
            response = requests.post(f"{self.base_url}/api/pull", 
                json={"name": model_name})
            if response.status_code == 200:
                print(f"Model {model_name} ready")
        except Exception as e:
            print(f"Failed to pull {model_name}: {e}")
    
    def get_agent_for_task(self, task_type: str) -> Agent:
        """Get appropriate agent based on task complexity."""
        model_category = self._classify_task(task_type)
        model_name = self.models[model_category]
        
        config = Config(
            name=f"ollama-{model_category}-agent",
            model_provider="ollama",
            model_id=model_name,
            endpoint=f"{self.base_url}/v1",
            api_key="ollama"
        )
        
        return Agent(config=config)
    
    def _classify_task(self, task_type: str) -> str:
        """Classify task to appropriate model category."""
        if any(keyword in task_type.lower() for keyword in ["simple", "route", "classify"]):
            return "lightweight"
        elif any(keyword in task_type.lower() for keyword in ["code", "programming", "debug"]):
            return "coding"
        elif any(keyword in task_type.lower() for keyword in ["complex", "analysis", "research"]):
            return "capable"
        else:
            return "balanced"

# Usage example
manager = OllamaMultiModelManager()

# Get appropriate agents for different tasks
routing_agent = manager.get_agent_for_task("simple routing")
coding_agent = manager.get_agent_for_task("code debugging")
analysis_agent = manager.get_agent_for_task("complex analysis")
```

#### Patrones de Despliegue en Producci√≥n

**Servicio de Producci√≥n con Ollama**:
```python
import asyncio
import logging
from typing import Dict, Optional
from microsoft_agent_framework import Agent, Config
import requests
import openai

class OllamaProductionService:
    def __init__(self, models_config: Dict[str, str]):
        self.models_config = models_config
        self.base_url = "http://localhost:11434"
        self.agents = {}
        self.metrics = {
            "requests_processed": 0,
            "errors": 0,
            "model_usage": {model: 0 for model in models_config.keys()}
        }
        self._initialize_production_agents()
    
    def _initialize_production_agents(self):
        """Initialize production agents with health checks."""
        for agent_type, model_name in self.models_config.items():
            try:
                # Ensure model is available
                self._ensure_model_ready(model_name)
                
                # Create production agent
                config = Config(
                    name=f"production-{agent_type}",
                    model_provider="ollama",
                    model_id=model_name,
                    endpoint=f"{self.base_url}/v1",
                    api_key="ollama",
                    max_tokens=512,
                    temperature=0.1,
                    timeout=30.0
                )
                
                agent = Agent(config=config)
                
                # Add production tools based on agent type
                self._add_production_tools(agent, agent_type)
                
                self.agents[agent_type] = agent
                logging.info(f"Initialized {agent_type} agent with model {model_name}")
                
            except Exception as e:
                logging.error(f"Failed to initialize {agent_type} agent: {e}")
    
    def _ensure_model_ready(self, model_name: str):
        """Ensure model is pulled and ready for use."""
        try:
            # Check if model exists
            response = requests.get(f"{self.base_url}/api/tags")
            models = response.json().get('models', [])
            
            model_exists = any(model['name'] == model_name for model in models)
            
            if not model_exists:
                logging.info(f"Pulling model {model_name}...")
                pull_response = requests.post(f"{self.base_url}/api/pull", 
                    json={"name": model_name})
                
                if pull_response.status_code != 200:
                    raise Exception(f"Failed to pull model {model_name}")
                    
        except Exception as e:
            raise Exception(f"Model setup failed for {model_name}: {e}")
    
    def _add_production_tools(self, agent: Agent, agent_type: str):
        """Add tools based on agent type."""
        if agent_type == "customer_service":
            @agent.tool
            def lookup_customer(customer_id: str) -> dict:
                """Look up customer information."""
                # Simulate database lookup
                return {"customer_id": customer_id, "status": "active", "tier": "premium"}
            
            @agent.tool
            def create_support_ticket(issue: str, priority: str = "medium") -> str:
                """Create a support ticket."""
                ticket_id = f"TICK-{hash(issue) % 10000:04d}"
                return f"Created ticket {ticket_id} with priority {priority}"
        
        elif agent_type == "technical_support":
            @agent.tool
            def run_diagnostics(system_info: str) -> dict:
                """Run system diagnostics."""
                return {"status": "healthy", "issues": [], "recommendations": []}
            
            @agent.tool
            def access_knowledge_base(query: str) -> str:
                """Search technical knowledge base."""
                return f"Knowledge base results for: {query}"
    
    async def process_request(self, request: str, agent_type: str = "customer_service") -> dict:
        """Process user request with monitoring and error handling."""
        start_time = time.time()
        
        try:
            if agent_type not in self.agents:
                raise ValueError(f"Agent type {agent_type} not available")
            
            agent = self.agents[agent_type]
            response = await agent.chat_async(request)
            
            # Update metrics
            self.metrics["requests_processed"] += 1
            self.metrics["model_usage"][agent_type] += 1
            
            processing_time = time.time() - start_time
            
            self._log_interaction(request, response, "success", processing_time, agent_type)
            
            return {
                "response": response,
                "status": "success",
                "processing_time": processing_time,
                "agent_type": agent_type
            }
            
        except Exception as e:
            self.metrics["errors"] += 1
            processing_time = time.time() - start_time
            
            self._log_interaction(request, str(e), "error", processing_time, agent_type)
            
            return {
                "response": "I'm experiencing technical difficulties. Please try again.",
                "status": "error",
                "error": str(e),
                "processing_time": processing_time
            }
    
    def _log_interaction(self, request: str, response: str, status: str, 
                        processing_time: float, agent_type: str):
        """Log interaction for monitoring and analysis."""
        logging.info(f"Agent: {agent_type}, Status: {status}, Time: {processing_time:.2f}s")
        
        # In production, this would write to a proper logging system
        log_entry = {
            "timestamp": time.time(),
            "agent_type": agent_type,
            "request_length": len(request),
            "response_length": len(response),
            "status": status,
            "processing_time": processing_time
        }
    
    def get_health_status(self) -> dict:
        """Get service health status."""
        try:
            # Check Ollama service health
            response = requests.get(f"{self.base_url}/api/tags", timeout=5)
            ollama_healthy = response.status_code == 200
            
            # Check model availability
            available_models = []
            if ollama_healthy:
                models = response.json().get('models', [])
                available_models = [model['name'] for model in models]
            
            return {
                "service_status": "healthy" if ollama_healthy else "unhealthy",
                "ollama_endpoint": self.base_url,
                "available_models": available_models,
                "active_agents": list(self.agents.keys()),
                "metrics": self.metrics,
                "timestamp": time.time()
            }
            
        except Exception as e:
            return {
                "service_status": "error",
                "error": str(e),
                "timestamp": time.time()
            }

# Production deployment example
production_models = {
    "customer_service": "phi3.5:3.8b-mini-instruct-q4_K_M",
    "technical_support": "llama3.2:3b-instruct-q4_K_M",
    "routing": "qwen2.5:0.5b-instruct-q4_K_M"
}

service = OllamaProductionService(production_models)

# Process requests
result = await service.process_request(
    "I need help with my account settings", 
    "customer_service"
)
print(result)
```

#### Caracter√≠sticas Empresariales y Monitoreo

**Monitoreo y Observabilidad de Ollama**:
```python
import time
import asyncio
import requests
from typing import Dict, List

class OllamaMonitoringService:
    def __init__(self, base_url: str = "http://localhost:11434"):
        self.base_url = base_url
        self.metrics_history = []
        self.alert_thresholds = {
            "response_time_ms": 2000,
            "error_rate_percent": 5,
            "memory_usage_percent": 85
        }
    
    async def collect_metrics(self) -> dict:
        """Collect comprehensive metrics from Ollama service."""
        metrics = {
            "timestamp": time.time(),
            "service_status": "unknown",
            "models": {},
            "performance": {},
            "resources": {}
        }
        
        try:
            # Check service health
            health_response = requests.get(f"{self.base_url}/api/tags", timeout=5)
            metrics["service_status"] = "healthy" if health_response.status_code == 200 else "unhealthy"
            
            if metrics["service_status"] == "healthy":
                # Get model information
                models_data = health_response.json().get('models', [])
                for model in models_data:
                    model_name = model['name']
                    metrics["models"][model_name] = {
                        "size_gb": model.get('size', 0) / (1024**3),
                        "modified": model.get('modified_at', ''),
                        "digest": model.get('digest', '')[:12]  # Short digest
                    }
                
                # Test inference performance
                start_time = time.time()
                test_response = requests.post(f"{self.base_url}/api/generate", 
                    json={
                        "model": list(metrics["models"].keys())[0] if metrics["models"] else "",
                        "prompt": "Hello",
                        "stream": False
                    }, timeout=10)
                
                if test_response.status_code == 200:
                    inference_time = (time.time() - start_time) * 1000
                    metrics["performance"] = {
                        "inference_time_ms": inference_time,
                        "tokens_per_second": self._calculate_tokens_per_second(test_response.json()),
                        "last_successful_inference": time.time()
                    }
            
        except Exception as e:
            metrics["service_status"] = "error"
            metrics["error"] = str(e)
        
        self.metrics_history.append(metrics)
        
        # Keep only last 100 metrics entries
        if len(self.metrics_history) > 100:
            self.metrics_history = self.metrics_history[-100:]
        
        return metrics
    
    def _calculate_tokens_per_second(self, response_data: dict) -> float:
        """Calculate approximate tokens per second from response."""
        try:
            # Estimate tokens (rough approximation)
            response_text = response_data.get('response', '')
            estimated_tokens = len(response_text.split())
            
            # Get timing info if available
            eval_duration = response_data.get('eval_duration', 0)
            if eval_duration > 0:
                # Convert nanoseconds to seconds
                duration_seconds = eval_duration / 1e9
                return estimated_tokens / duration_seconds if duration_seconds > 0 else 0
        except:
            pass
        return 0
    
    def check_alerts(self, current_metrics: dict) -> List[dict]:
        """Check current metrics against alert thresholds."""
        alerts = []
        
        # Check response time
        if current_metrics.get('performance', {}).get('inference_time_ms', 0) > self.alert_thresholds['response_time_ms']:
            alerts.append({
                "type": "performance",
                "message": f"High response time: {current_metrics['performance']['inference_time_ms']:.0f}ms",
                "severity": "warning"
            })
        
        # Check service status
        if current_metrics.get('service_status') != 'healthy':
            alerts.append({
                "type": "availability",
                "message": f"Service unhealthy: {current_metrics.get('error', 'Unknown error')}",
                "severity": "critical"
            })
        
        return alerts
    
    def get_performance_summary(self, minutes: int = 60) -> dict:
        """Get performance summary for the last N minutes."""
        cutoff_time = time.time() - (minutes * 60)
        recent_metrics = [m for m in self.metrics_history if m['timestamp'] > cutoff_time]
        
        if not recent_metrics:
            return {"error": "No recent metrics available"}
        
        # Calculate averages
        response_times = [m.get('performance', {}).get('inference_time_ms', 0) 
                         for m in recent_metrics if m.get('performance')]
        
        healthy_checks = sum(1 for m in recent_metrics if m.get('service_status') == 'healthy')
        uptime_percent = (healthy_checks / len(recent_metrics)) * 100 if recent_metrics else 0
        
        return {
            "period_minutes": minutes,
            "total_checks": len(recent_metrics),
            "uptime_percent": uptime_percent,
            "avg_response_time_ms": sum(response_times) / len(response_times) if response_times else 0,
            "max_response_time_ms": max(response_times) if response_times else 0,
            "min_response_time_ms": min(response_times) if response_times else 0
        }

# Production monitoring setup
monitor = OllamaMonitoringService()

async def monitoring_loop():
    """Continuous monitoring loop."""
    while True:
        try:
            metrics = await monitor.collect_metrics()
            alerts = monitor.check_alerts(metrics)
            
            if alerts:
                for alert in alerts:
                    logging.warning(f"ALERT: {alert['message']} (Severity: {alert['severity']})")
            
            # Log performance summary every 10 minutes
            if int(time.time()) % 600 == 0:  # Every 10 minutes
                summary = monitor.get_performance_summary(10)
                logging.info(f"Performance Summary: {summary}")
            
        except Exception as e:
            logging.error(f"Monitoring error: {e}")
        
        await asyncio.sleep(30)  # Check every 30 seconds

# Start monitoring
# asyncio.create_task(monitoring_loop())
```

#### Configuraci√≥n y Optimizaci√≥n Avanzadas

**Gesti√≥n Personalizada de Modelos con Ollama**:
```python
class OllamaModelManager:
    def __init__(self, base_url: str = "http://localhost:11434"):
        self.base_url = base_url
        self.model_catalog = {
            # Lightweight models for fast responses
            "ultra_light": [
                "qwen2.5:0.5b-instruct-q4_K_M",
                "tinyllama:1.1b-chat-q4_K_M"
            ],
            # Balanced models for general use
            "balanced": [
                "phi3.5:3.8b-mini-instruct-q4_K_M",
                "llama3.2:3b-instruct-q4_K_M"
            ],
            # Specialized models for specific tasks
            "code_specialist": [
                "codellama:7b-code-q4_K_M",
                "codegemma:7b-code-q4_K_M"
            ],
            # High capability models
            "high_capability": [
                "llama3.1:8b-instruct-q4_K_M",
                "qwen2.5:7b-instruct-q4_K_M"
            ]
        }
    
    def setup_production_models(self, categories: List[str]) -> dict:
        """Set up models for production use."""
        setup_results = {}
        
        for category in categories:
            if category not in self.model_catalog:
                setup_results[category] = {"status": "error", "message": "Unknown category"}
                continue
            
            models = self.model_catalog[category]
            category_results = []
            
            for model in models:
                try:
                    # Pull model
                    response = requests.post(f"{self.base_url}/api/pull", 
                        json={"name": model})
                    
                    if response.status_code == 200:
                        category_results.append({"model": model, "status": "ready"})
                    else:
                        category_results.append({"model": model, "status": "failed"})
                        
                except Exception as e:
                    category_results.append({"model": model, "status": "error", "error": str(e)})
            
            setup_results[category] = category_results
        
        return setup_results
    
    def optimize_for_hardware(self) -> dict:
        """Recommend optimal models based on available hardware."""
        # This would typically check actual hardware specs
        # For demo purposes, we'll simulate hardware detection
        
        recommendations = {
            "low_resource": {
                "models": ["qwen2.5:0.5b-instruct-q4_K_M"],
                "max_concurrent": 1,
                "memory_usage": "< 1GB"
            },
            "medium_resource": {
                "models": ["phi3.5:3.8b-mini-instruct-q4_K_M", "llama3.2:3b-instruct-q4_K_M"],
                "max_concurrent": 2,
                "memory_usage": "2-4GB"
            },
            "high_resource": {
                "models": ["llama3.1:8b-instruct-q4_K_M", "codellama:7b-code-q4_K_M"],
                "max_concurrent": 3,
                "memory_usage": "6-12GB"
            }
        }
        
        return recommendations

# Production model setup
model_manager = OllamaModelManager()
setup_results = model_manager.setup_production_models(["balanced", "ultra_light"])
print(f"Model setup results: {setup_results}")
```

**Lista de Verificaci√≥n para Despliegue en Producci√≥n con Ollama**:

‚úÖ **Configuraci√≥n del Servicio**:
- Instalar el servicio Ollama con integraci√≥n adecuada al sistema
- Configurar modelos para casos de uso espec√≠ficos de agentes
- Establecer scripts de inicio y gesti√≥n del servicio adecuados
- Probar la carga de modelos y disponibilidad de API

‚úÖ **Gesti√≥n de Modelos**:
- Descargar los modelos requeridos y verificar su integridad
- Establecer procedimientos de actualizaci√≥n y rotaci√≥n de modelos
- Configurar almacenamiento en cach√© y optimizaci√≥n de almacenamiento de modelos
- Probar el rendimiento del modelo bajo carga esperada

‚úÖ **Configuraci√≥n de Seguridad**:
- Configurar reglas de firewall para acceso solo local
- Establecer controles de acceso API y limitaci√≥n de tasa
- Implementar registro de auditor√≠a para interacciones de agentes
- Configurar almacenamiento seguro de modelos y acceso

‚úÖ **Optimizaci√≥n de Rendimiento**:
- Evaluar modelos para casos de uso esperados
- Configurar aceleraci√≥n de hardware adecuada
- Establecer estrategias de calentamiento y almacenamiento en cach√© de modelos
- Monitorear m√©tricas de uso de recursos y rendimiento

‚úÖ **Pruebas de Integraci√≥n**:
- Probar la integraci√≥n del Marco de Agentes de Microsoft  
- Verificar las capacidades de operaci√≥n sin conexi√≥n  
- Probar escenarios de conmutaci√≥n por error y manejo de errores  
- Validar los flujos de trabajo de agentes de extremo a extremo  

**Comparaci√≥n con Foundry Local**:

| Caracter√≠stica | Foundry Local | Ollama |
|----------------|---------------|--------|
| **Caso de uso objetivo** | Producci√≥n empresarial | Desarrollo y comunidad |
| **Ecosistema de modelos** | Curado por Microsoft | Comunidad extensa |
| **Optimizaci√≥n de hardware** | Autom√°tica (CUDA/NPU/CPU) | Configuraci√≥n manual |
| **Caracter√≠sticas empresariales** | Monitoreo y seguridad integrados | Herramientas comunitarias |
| **Complejidad de implementaci√≥n** | Simple (instalaci√≥n con winget) | Simple (instalaci√≥n con curl) |
| **Compatibilidad con API** | OpenAI + extensiones | Est√°ndar OpenAI |
| **Soporte** | Oficial de Microsoft | Impulsado por la comunidad |
| **Mejor para** | Agentes de producci√≥n | Prototipos, investigaci√≥n |

**Cu√°ndo elegir Ollama**:  
- **Desarrollo y Prototipos**: Experimentaci√≥n r√°pida con diferentes modelos  
- **Modelos Comunitarios**: Acceso a los √∫ltimos modelos contribuidos por la comunidad  
- **Uso Educativo**: Aprender y ense√±ar desarrollo de agentes de IA  
- **Proyectos de Investigaci√≥n**: Investigaci√≥n acad√©mica que requiere acceso a modelos diversos  
- **Modelos Personalizados**: Construcci√≥n y prueba de modelos ajustados personalizados  

### VLLM: Inferencia de Agentes SLM de Alto Rendimiento  

VLLM (inferencia de modelos de lenguaje muy grandes) proporciona un motor de inferencia de alto rendimiento y eficiente en memoria, espec√≠ficamente optimizado para implementaciones de SLM en producci√≥n a gran escala. Mientras que Foundry Local se centra en la facilidad de uso y Ollama enfatiza los modelos comunitarios, VLLM sobresale en escenarios de alto rendimiento que requieren m√°ximo rendimiento y utilizaci√≥n eficiente de recursos.  

**Arquitectura y caracter√≠sticas principales**:  
- **PagedAttention**: Gesti√≥n revolucionaria de memoria para c√°lculos de atenci√≥n eficientes  
- **Batching din√°mico**: Agrupaci√≥n inteligente de solicitudes para un rendimiento √≥ptimo  
- **Optimizaci√≥n de GPU**: N√∫cleos avanzados de CUDA y soporte de paralelismo tensorial  
- **Compatibilidad con OpenAI**: Compatibilidad total con API para una integraci√≥n fluida  
- **Decodificaci√≥n especulativa**: T√©cnicas avanzadas de aceleraci√≥n de inferencia  
- **Soporte de cuantizaci√≥n**: Cuantizaci√≥n INT4, INT8 y FP16 para eficiencia de memoria  

#### Instalaci√≥n y Configuraci√≥n  

**Opciones de instalaci√≥n**:  
```bash
# Standard installation
pip install vllm

# With additional dependencies for agent frameworks
pip install vllm[agent] openai

# Docker deployment for production
docker pull vllm/vllm-openai:latest

# From source for latest features
git clone https://github.com/vllm-project/vllm.git
cd vllm
pip install -e .
```
  
**Inicio r√°pido para desarrollo de agentes**:  
```bash
# Start VLLM server with SLM model
python -m vllm.entrypoints.openai.api_server \
    --model microsoft/Phi-3.5-mini-instruct \
    --trust-remote-code \
    --max-model-len 4096 \
    --gpu-memory-utilization 0.8

# Alternative: Start with Qwen2.5 for lightweight agents
python -m vllm.entrypoints.openai.api_server \
    --model Qwen/Qwen2.5-0.5B-Instruct \
    --trust-remote-code \
    --max-model-len 2048 \
    --tensor-parallel-size 1

# Test API endpoint
curl http://localhost:8000/v1/models

# Test chat completion
curl http://localhost:8000/v1/chat/completions \
    -H "Content-Type: application/json" \
    -d '{
        "model": "microsoft/Phi-3.5-mini-instruct",
        "messages": [{"role": "user", "content": "Hello!"}]
    }'
```
  

#### Integraci√≥n con el Marco de Agentes  

**VLLM con el Marco de Agentes de Microsoft**:  
```python
from microsoft_agent_framework import Agent, Config
import openai
import subprocess
import time
import requests
from typing import Optional, Dict, Any

class VLLMManager:
    def __init__(self, model_name: str, 
                 host: str = "localhost", 
                 port: int = 8000,
                 gpu_memory_utilization: float = 0.8,
                 max_model_len: int = 4096):
        self.model_name = model_name
        self.host = host
        self.port = port
        self.base_url = f"http://{host}:{port}"
        self.gpu_memory_utilization = gpu_memory_utilization
        self.max_model_len = max_model_len
        self.process = None
        self.client = None
        
    def start_server(self) -> bool:
        """Start VLLM server with optimized settings for agents."""
        try:
            cmd = [
                "python", "-m", "vllm.entrypoints.openai.api_server",
                "--model", self.model_name,
                "--host", self.host,
                "--port", str(self.port),
                "--gpu-memory-utilization", str(self.gpu_memory_utilization),
                "--max-model-len", str(self.max_model_len),
                "--trust-remote-code",
                "--disable-log-requests",  # Reduce logging for agents
                "--served-model-name", self.get_served_model_name()
            ]
            
            self.process = subprocess.Popen(cmd, 
                stdout=subprocess.PIPE, 
                stderr=subprocess.PIPE)
            
            # Wait for server to start
            max_retries = 30
            for _ in range(max_retries):
                if self.health_check():
                    self.client = openai.OpenAI(base_url=f"{self.base_url}/v1")
                    return True
                time.sleep(2)
                
            return False
            
        except Exception as e:
            print(f"Failed to start VLLM server: {e}")
            return False
    
    def get_served_model_name(self) -> str:
        """Get a clean model name for serving."""
        return self.model_name.replace("/", "--")
    
    def health_check(self) -> bool:
        """Check if VLLM server is healthy."""
        try:
            response = requests.get(f"{self.base_url}/health", timeout=5)
            return response.status_code == 200
        except:
            return False
    
    def get_openai_client(self) -> openai.OpenAI:
        """Get OpenAI-compatible client for VLLM."""
        if not self.client:
            self.client = openai.OpenAI(base_url=f"{self.base_url}/v1")
        return self.client
    
    def get_model_info(self) -> Dict[str, Any]:
        """Get model information and statistics."""
        try:
            response = requests.get(f"{self.base_url}/v1/models")
            if response.status_code == 200:
                return response.json()
        except:
            pass
        return {}
    
    def shutdown(self):
        """Shutdown VLLM server."""
        if self.process:
            self.process.terminate()
            self.process.wait()

# Initialize VLLM for high-performance agents
vllm_manager = VLLMManager("microsoft/Phi-3.5-mini-instruct")
if vllm_manager.start_server():
    print("VLLM server started successfully")
    
    # Configure agent with VLLM backend
    agent_config = Config(
        name="vllm-performance-agent",
        model_provider="vllm",
        model_id=vllm_manager.get_served_model_name(),
        endpoint=f"{vllm_manager.base_url}/v1",
        api_key="none"  # VLLM doesn't require API key
    )
    
    agent = Agent(config=agent_config)
else:
    print("Failed to start VLLM server")
```
  
**Configuraci√≥n de m√∫ltiples agentes de alto rendimiento**:  
```python
import asyncio
from concurrent.futures import ThreadPoolExecutor
from microsoft_agent_framework import Agent, Config
import openai

class VLLMHighThroughputManager:
    def __init__(self):
        self.model_configs = {
            "lightweight": {
                "model": "Qwen/Qwen2.5-0.5B-Instruct",
                "port": 8000,
                "max_model_len": 2048,
                "gpu_memory_utilization": 0.3
            },
            "balanced": {
                "model": "microsoft/Phi-3.5-mini-instruct",
                "port": 8001,
                "max_model_len": 4096,
                "gpu_memory_utilization": 0.5
            },
            "capable": {
                "model": "meta-llama/Llama-3.2-3B-Instruct",
                "port": 8002,
                "max_model_len": 8192,
                "gpu_memory_utilization": 0.7
            }
        }
        self.managers = {}
        self.agents = {}
        self.client_pool = {}
        
    async def initialize_all_models(self):
        """Initialize all VLLM models in parallel."""
        initialization_tasks = []
        
        for category, config in self.model_configs.items():
            task = self._initialize_model(category, config)
            initialization_tasks.append(task)
        
        results = await asyncio.gather(*initialization_tasks, return_exceptions=True)
        
        successful_inits = 0
        for i, result in enumerate(results):
            category = list(self.model_configs.keys())[i]
            if isinstance(result, Exception):
                print(f"Failed to initialize {category}: {result}")
            else:
                successful_inits += 1
                print(f"Successfully initialized {category} model")
        
        return successful_inits
    
    async def _initialize_model(self, category: str, config: Dict[str, Any]):
        """Initialize a single VLLM model instance."""
        manager = VLLMManager(
            model_name=config["model"],
            port=config["port"],
            max_model_len=config["max_model_len"],
            gpu_memory_utilization=config["gpu_memory_utilization"]
        )
        
        # Start server in thread to avoid blocking
        loop = asyncio.get_event_loop()
        with ThreadPoolExecutor() as executor:
            success = await loop.run_in_executor(executor, manager.start_server)
        
        if success:
            self.managers[category] = manager
            
            # Create agent
            agent_config = Config(
                name=f"vllm-{category}-agent",
                model_provider="vllm",
                model_id=manager.get_served_model_name(),
                endpoint=f"{manager.base_url}/v1",
                api_key="none"
            )
            
            self.agents[category] = Agent(config=agent_config)
            
            # Create client pool for high throughput
            self.client_pool[category] = [
                openai.OpenAI(base_url=f"{manager.base_url}/v1")
                for _ in range(5)  # 5 clients per model for parallelism
            ]
            
            return True
        else:
            raise Exception(f"Failed to start VLLM server for {category}")
    
    def get_optimal_agent(self, request_complexity: str, current_load: Dict[str, int]) -> str:
        """Select optimal agent based on request complexity and current load."""
        complexity_mapping = {
            "simple": "lightweight",
            "moderate": "balanced", 
            "complex": "capable"
        }
        
        preferred_category = complexity_mapping.get(request_complexity, "balanced")
        
        # Check if preferred agent is available and not overloaded
        if (preferred_category in self.agents and 
            current_load.get(preferred_category, 0) < 10):  # Max 10 concurrent per agent
            return preferred_category
        
        # Fallback to least loaded available agent
        available_agents = [(cat, load) for cat, load in current_load.items() 
                          if cat in self.agents and load < 10]
        
        if available_agents:
            return min(available_agents, key=lambda x: x[1])[0]
        
        return "balanced"  # Default fallback
    
    async def process_batch_requests(self, requests: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Process multiple requests in parallel for maximum throughput."""
        current_load = {cat: 0 for cat in self.agents.keys()}
        tasks = []
        
        for request in requests:
            # Determine optimal agent
            complexity = request.get("complexity", "moderate")
            agent_category = self.get_optimal_agent(complexity, current_load)
            current_load[agent_category] += 1
            
            # Create processing task
            task = self._process_single_request(request, agent_category)
            tasks.append(task)
        
        # Process all requests in parallel
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # Format results
        formatted_results = []
        for i, result in enumerate(results):
            if isinstance(result, Exception):
                formatted_results.append({
                    "request_id": requests[i].get("id", i),
                    "status": "error",
                    "error": str(result)
                })
            else:
                formatted_results.append(result)
        
        return formatted_results
    
    async def _process_single_request(self, request: Dict[str, Any], agent_category: str) -> Dict[str, Any]:
        """Process a single request with the specified agent."""
        start_time = time.time()
        
        try:
            agent = self.agents[agent_category]
            response = await agent.chat_async(request["message"])
            
            processing_time = time.time() - start_time
            
            return {
                "request_id": request.get("id"),
                "status": "success",
                "response": response,
                "agent_used": agent_category,
                "processing_time": processing_time
            }
            
        except Exception as e:
            return {
                "request_id": request.get("id"),
                "status": "error",
                "error": str(e),
                "agent_used": agent_category,
                "processing_time": time.time() - start_time
            }

# High-throughput usage example
throughput_manager = VLLMHighThroughputManager()

# Initialize all models
initialized_count = await throughput_manager.initialize_all_models()
print(f"Initialized {initialized_count} models")

# Process batch requests
batch_requests = [
    {"id": 1, "message": "Simple question", "complexity": "simple"},
    {"id": 2, "message": "Complex analysis needed", "complexity": "complex"},
    {"id": 3, "message": "Moderate difficulty task", "complexity": "moderate"}
]

results = await throughput_manager.process_batch_requests(batch_requests)
for result in results:
    print(f"Request {result['request_id']}: {result['status']} in {result.get('processing_time', 0):.2f}s")
```
  

#### Patrones de implementaci√≥n en producci√≥n  

**Servicio de producci√≥n empresarial VLLM**:  
```python
import asyncio
import logging
import time
from typing import Dict, List, Optional
from dataclasses import dataclass
from microsoft_agent_framework import Agent, Config
import uvicorn
from fastapi import FastAPI, HTTPException, BackgroundTasks
from pydantic import BaseModel

@dataclass
class VLLMServerConfig:
    model_name: str
    port: int
    gpu_memory_utilization: float
    max_model_len: int
    tensor_parallel_size: int = 1
    quantization: Optional[str] = None

class AgentRequest(BaseModel):
    message: str
    agent_type: str = "general"
    priority: str = "normal"
    timeout: int = 30

class VLLMProductionService:
    def __init__(self, server_configs: Dict[str, VLLMServerConfig]):
        self.server_configs = server_configs
        self.managers = {}
        self.agents = {}
        self.metrics = {
            "requests_processed": 0,
            "requests_failed": 0,
            "total_processing_time": 0,
            "agent_usage": {name: 0 for name in server_configs.keys()},
            "throughput_per_minute": 0
        }
        self.request_queue = asyncio.Queue(maxsize=1000)
        self.processing_workers = []
        self.app = FastAPI(title="VLLM Agent Service")
        self._setup_routes()
        
    async def initialize_production_environment(self):
        """Initialize all VLLM servers for production."""
        logging.info("Initializing VLLM production environment...")
        
        initialization_tasks = []
        for name, config in self.server_configs.items():
            task = self._initialize_server(name, config)
            initialization_tasks.append(task)
        
        results = await asyncio.gather(*initialization_tasks, return_exceptions=True)
        
        successful_servers = 0
        for i, result in enumerate(results):
            server_name = list(self.server_configs.keys())[i]
            if isinstance(result, Exception):
                logging.error(f"Failed to initialize {server_name}: {result}")
            else:
                successful_servers += 1
                logging.info(f"Successfully initialized {server_name}")
        
        if successful_servers == 0:
            raise Exception("No VLLM servers could be initialized")
        
        # Start processing workers
        self.processing_workers = [
            asyncio.create_task(self._processing_worker(i))
            for i in range(min(4, successful_servers))  # 4 workers max
        ]
        
        logging.info(f"Production environment ready with {successful_servers} servers")
        return successful_servers
    
    async def _initialize_server(self, name: str, config: VLLMServerConfig):
        """Initialize a single VLLM server."""
        manager = VLLMManager(
            model_name=config.model_name,
            port=config.port,
            gpu_memory_utilization=config.gpu_memory_utilization,
            max_model_len=config.max_model_len
        )
        
        # Add quantization if specified
        if config.quantization:
            # This would be added to the manager's start command
            pass
        
        success = manager.start_server()
        if success:
            self.managers[name] = manager
            
            # Create production agent
            agent_config = Config(
                name=f"vllm-production-{name}",
                model_provider="vllm",
                model_id=manager.get_served_model_name(),
                endpoint=f"{manager.base_url}/v1",
                api_key="none",
                timeout=30.0
            )
            
            agent = Agent(config=agent_config)
            
            # Add production tools
            self._add_production_tools(agent, name)
            
            self.agents[name] = agent
            return True
        else:
            raise Exception(f"Failed to start VLLM server for {name}")
    
    def _add_production_tools(self, agent: Agent, server_type: str):
        """Add production tools based on server type."""
        if server_type == "customer_service":
            @agent.tool
            def escalate_to_human(issue: str, customer_id: str) -> str:
                """Escalate complex issues to human agents."""
                return f"Escalated issue for customer {customer_id}: {issue}"
            
            @agent.tool
            def lookup_order_status(order_id: str) -> dict:
                """Look up order status from production database."""
                # Production database lookup
                return {"order_id": order_id, "status": "shipped", "eta": "2 days"}
        
        elif server_type == "technical_support":
            @agent.tool
            def run_system_diagnostics(system_id: str) -> dict:
                """Run comprehensive system diagnostics."""
                return {"system_id": system_id, "status": "healthy", "issues": []}
            
            @agent.tool
            def create_incident_report(description: str, severity: str) -> str:
                """Create incident report in production system."""
                incident_id = f"INC-{hash(description) % 100000:05d}"
                return f"Created incident {incident_id} with severity {severity}"
    
    def _setup_routes(self):
        """Set up FastAPI routes for production service."""
        @self.app.post("/chat")
        async def chat_endpoint(request: AgentRequest, background_tasks: BackgroundTasks):
            try:
                # Add request to queue
                await self.request_queue.put({
                    "request": request,
                    "timestamp": time.time(),
                    "future": asyncio.Future()
                })
                
                # Wait for processing (with timeout)
                result = await asyncio.wait_for(
                    self._wait_for_result(request),
                    timeout=request.timeout
                )
                
                return result
                
            except asyncio.TimeoutError:
                raise HTTPException(status_code=408, detail="Request timeout")
            except Exception as e:
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.get("/health")
        async def health_endpoint():
            return await self.get_health_status()
        
        @self.app.get("/metrics")
        async def metrics_endpoint():
            return self.get_production_metrics()
    
    async def _processing_worker(self, worker_id: int):
        """Background worker for processing agent requests."""
        logging.info(f"Starting processing worker {worker_id}")
        
        while True:
            try:
                # Get request from queue
                queue_item = await self.request_queue.get()
                request_data = queue_item["request"]
                request_future = queue_item["future"]
                
                # Select appropriate agent
                agent_name = self._select_agent(request_data.agent_type)
                
                if agent_name not in self.agents:
                    request_future.set_exception(Exception(f"Agent {agent_name} not available"))
                    continue
                
                # Process request
                start_time = time.time()
                try:
                    agent = self.agents[agent_name]
                    response = await agent.chat_async(request_data.message)
                    
                    processing_time = time.time() - start_time
                    
                    # Update metrics
                    self.metrics["requests_processed"] += 1
                    self.metrics["total_processing_time"] += processing_time
                    self.metrics["agent_usage"][agent_name] += 1
                    
                    result = {
                        "response": response,
                        "agent_used": agent_name,
                        "processing_time": processing_time,
                        "worker_id": worker_id
                    }
                    
                    request_future.set_result(result)
                    
                except Exception as e:
                    self.metrics["requests_failed"] += 1
                    request_future.set_exception(e)
                
                finally:
                    self.request_queue.task_done()
                    
            except Exception as e:
                logging.error(f"Worker {worker_id} error: {e}")
                await asyncio.sleep(1)
    
    def _select_agent(self, agent_type: str) -> str:
        """Select appropriate agent based on request type."""
        agent_mapping = {
            "customer_service": "customer_service",
            "technical": "technical_support",
            "general": "general_purpose"
        }
        
        return agent_mapping.get(agent_type, "general_purpose")
    
    async def _wait_for_result(self, request: AgentRequest):
        """Wait for request processing to complete."""
        # This is simplified - in production you'd track futures properly
        await asyncio.sleep(0.1)  # Placeholder
        return {"response": "Processed", "status": "success"}
    
    async def get_health_status(self) -> dict:
        """Get comprehensive health status of all services."""
        health_status = {
            "overall_status": "healthy",
            "servers": {},
            "queue_size": self.request_queue.qsize(),
            "active_workers": len([w for w in self.processing_workers if not w.done()]),
            "timestamp": time.time()
        }
        
        unhealthy_servers = 0
        for name, manager in self.managers.items():
            try:
                is_healthy = manager.health_check()
                health_status["servers"][name] = {
                    "status": "healthy" if is_healthy else "unhealthy",
                    "endpoint": manager.base_url,
                    "model": manager.model_name
                }
                if not is_healthy:
                    unhealthy_servers += 1
            except Exception as e:
                health_status["servers"][name] = {
                    "status": "error",
                    "error": str(e)
                }
                unhealthy_servers += 1
        
        if unhealthy_servers > 0:
            health_status["overall_status"] = "degraded" if unhealthy_servers < len(self.managers) else "unhealthy"
        
        return health_status
    
    def get_production_metrics(self) -> dict:
        """Get production performance metrics."""
        total_requests = self.metrics["requests_processed"] + self.metrics["requests_failed"]
        avg_processing_time = (
            self.metrics["total_processing_time"] / self.metrics["requests_processed"]
            if self.metrics["requests_processed"] > 0 else 0
        )
        
        success_rate = (
            self.metrics["requests_processed"] / total_requests * 100
            if total_requests > 0 else 0
        )
        
        return {
            "total_requests": total_requests,
            "successful_requests": self.metrics["requests_processed"],
            "failed_requests": self.metrics["requests_failed"],
            "success_rate_percent": success_rate,
            "average_processing_time_seconds": avg_processing_time,
            "agent_usage_distribution": self.metrics["agent_usage"],
            "queue_size": self.request_queue.qsize()
        }
    
    async def start_production_server(self, host: str = "0.0.0.0", port: int = 8080):
        """Start the production FastAPI server."""
        config = uvicorn.Config(
            self.app,
            host=host,
            port=port,
            log_level="info",
            workers=1  # Single worker for simplicity
        )
        server = uvicorn.Server(config)
        await server.serve()

# Production deployment example
production_configs = {
    "customer_service": VLLMServerConfig(
        model_name="microsoft/Phi-3.5-mini-instruct",
        port=8000,
        gpu_memory_utilization=0.4,
        max_model_len=4096
    ),
    "technical_support": VLLMServerConfig(
        model_name="meta-llama/Llama-3.2-3B-Instruct",
        port=8001,
        gpu_memory_utilization=0.6,
        max_model_len=8192
    ),
    "general_purpose": VLLMServerConfig(
        model_name="Qwen/Qwen2.5-1.5B-Instruct",
        port=8002,
        gpu_memory_utilization=0.3,
        max_model_len=2048
    )
}

production_service = VLLMProductionService(production_configs)

# Initialize and start production service
# await production_service.initialize_production_environment()
# await production_service.start_production_server()
```
  

#### Caracter√≠sticas empresariales y monitoreo  

**Monitoreo avanzado de rendimiento VLLM**:  
```python
import psutil
import nvidia_ml_py3 as nvml
from dataclasses import dataclass
from typing import List, Dict, Optional
import json
import asyncio

@dataclass
class PerformanceMetrics:
    timestamp: float
    requests_per_second: float
    average_latency_ms: float
    gpu_utilization_percent: float
    gpu_memory_used_gb: float
    cpu_utilization_percent: float
    memory_used_gb: float
    queue_length: int
    active_requests: int

class VLLMAdvancedMonitoring:
    def __init__(self, vllm_managers: Dict[str, VLLMManager]):
        self.managers = vllm_managers
        self.metrics_history = []
        self.alert_thresholds = {
            "gpu_utilization_max": 95,
            "gpu_memory_max_gb": 10,
            "latency_max_ms": 3000,
            "queue_length_max": 50,
            "error_rate_max_percent": 10
        }
        
        # Initialize NVIDIA ML for GPU monitoring
        try:
            nvml.nvmlInit()
            self.gpu_monitoring_available = True
            self.gpu_count = nvml.nvmlDeviceGetCount()
        except:
            self.gpu_monitoring_available = False
            self.gpu_count = 0
    
    async def collect_comprehensive_metrics(self) -> Dict[str, PerformanceMetrics]:
        """Collect detailed performance metrics for all VLLM instances."""
        all_metrics = {}
        
        for name, manager in self.managers.items():
            try:
                metrics = await self._collect_single_instance_metrics(name, manager)
                all_metrics[name] = metrics
            except Exception as e:
                logging.error(f"Failed to collect metrics for {name}: {e}")
                # Create error metrics
                all_metrics[name] = PerformanceMetrics(
                    timestamp=time.time(),
                    requests_per_second=0,
                    average_latency_ms=0,
                    gpu_utilization_percent=0,
                    gpu_memory_used_gb=0,
                    cpu_utilization_percent=0,
                    memory_used_gb=0,
                    queue_length=0,
                    active_requests=0
                )
        
        return all_metrics
    
    async def _collect_single_instance_metrics(self, name: str, manager: VLLMManager) -> PerformanceMetrics:
        """Collect metrics for a single VLLM instance."""
        timestamp = time.time()
        
        # Get VLLM-specific metrics via API
        vllm_stats = await self._get_vllm_stats(manager)
        
        # Get system metrics
        cpu_percent = psutil.cpu_percent(interval=0.1)
        memory_info = psutil.virtual_memory()
        memory_used_gb = memory_info.used / (1024**3)
        
        # Get GPU metrics if available
        gpu_utilization = 0
        gpu_memory_used = 0
        
        if self.gpu_monitoring_available and self.gpu_count > 0:
            try:
                # Assuming first GPU for simplicity
                handle = nvml.nvmlDeviceGetHandleByIndex(0)
                gpu_util = nvml.nvmlDeviceGetUtilizationRates(handle)
                gpu_utilization = gpu_util.gpu
                
                gpu_mem = nvml.nvmlDeviceGetMemoryInfo(handle)
                gpu_memory_used = gpu_mem.used / (1024**3)
                
            except Exception as e:
                logging.warning(f"GPU monitoring failed: {e}")
        
        return PerformanceMetrics(
            timestamp=timestamp,
            requests_per_second=vllm_stats.get("requests_per_second", 0),
            average_latency_ms=vllm_stats.get("average_latency_ms", 0),
            gpu_utilization_percent=gpu_utilization,
            gpu_memory_used_gb=gpu_memory_used,
            cpu_utilization_percent=cpu_percent,
            memory_used_gb=memory_used_gb,
            queue_length=vllm_stats.get("queue_length", 0),
            active_requests=vllm_stats.get("active_requests", 0)
        )
    
    async def _get_vllm_stats(self, manager: VLLMManager) -> dict:
        """Get VLLM-specific statistics via API calls."""
        try:
            # Test inference to measure latency
            start_time = time.time()
            client = manager.get_openai_client()
            
            response = await asyncio.wait_for(
                asyncio.to_thread(
                    client.chat.completions.create,
                    model=manager.get_served_model_name(),
                    messages=[{"role": "user", "content": "ping"}],
                    max_tokens=1
                ),
                timeout=5.0
            )
            
            latency_ms = (time.time() - start_time) * 1000
            
            return {
                "average_latency_ms": latency_ms,
                "requests_per_second": 1000 / latency_ms if latency_ms > 0 else 0,
                "queue_length": 0,  # Would need to be exposed by VLLM
                "active_requests": 1  # Approximation
            }
            
        except Exception as e:
            logging.warning(f"Failed to get VLLM stats: {e}")
            return {
                "average_latency_ms": 0,
                "requests_per_second": 0,
                "queue_length": 0,
                "active_requests": 0
            }
    
    def generate_performance_report(self, time_window_minutes: int = 60) -> dict:
        """Generate comprehensive performance report."""
        cutoff_time = time.time() - (time_window_minutes * 60)
        recent_metrics = [
            metrics for metrics in self.metrics_history
            if any(m.timestamp > cutoff_time for m in metrics.values())
        ]
        
        if not recent_metrics:
            return {"error": "No recent metrics available"}
        
        report = {
            "time_window_minutes": time_window_minutes,
            "total_samples": len(recent_metrics),
            "instances": {}
        }
        
        # Analyze each instance
        for instance_name in self.managers.keys():
            instance_metrics = [
                metrics[instance_name] for metrics in recent_metrics
                if instance_name in metrics
            ]
            
            if instance_metrics:
                report["instances"][instance_name] = {
                    "avg_latency_ms": sum(m.average_latency_ms for m in instance_metrics) / len(instance_metrics),
                    "max_latency_ms": max(m.average_latency_ms for m in instance_metrics),
                    "avg_gpu_utilization": sum(m.gpu_utilization_percent for m in instance_metrics) / len(instance_metrics),
                    "avg_requests_per_second": sum(m.requests_per_second for m in instance_metrics) / len(instance_metrics),
                    "max_queue_length": max(m.queue_length for m in instance_metrics),
                    "availability_percent": (len(instance_metrics) / len(recent_metrics)) * 100
                }
        
        return report
    
    async def auto_scaling_recommendations(self) -> List[dict]:
        """Generate auto-scaling recommendations based on performance metrics."""
        recommendations = []
        
        if not self.metrics_history:
            return recommendations
        
        latest_metrics = self.metrics_history[-1]
        
        for instance_name, metrics in latest_metrics.items():
            # High latency recommendation
            if metrics.average_latency_ms > self.alert_thresholds["latency_max_ms"]:
                recommendations.append({
                    "instance": instance_name,
                    "type": "scale_up",
                    "reason": f"High latency: {metrics.average_latency_ms:.0f}ms",
                    "suggestion": "Consider adding tensor parallelism or increasing GPU memory"
                })
            
            # High GPU utilization recommendation
            if metrics.gpu_utilization_percent > self.alert_thresholds["gpu_utilization_max"]:
                recommendations.append({
                    "instance": instance_name,
                    "type": "scale_out",
                    "reason": f"High GPU utilization: {metrics.gpu_utilization_percent:.1f}%",
                    "suggestion": "Consider adding additional GPU instances"
                })
            
            # Low utilization recommendation
            if (metrics.gpu_utilization_percent < 20 and 
                metrics.requests_per_second < 1):
                recommendations.append({
                    "instance": instance_name,
                    "type": "scale_down",
                    "reason": f"Low utilization: {metrics.gpu_utilization_percent:.1f}% GPU, {metrics.requests_per_second:.1f} RPS",
                    "suggestion": "Consider consolidating workloads or reducing resources"
                })
        
        return recommendations

# Advanced monitoring setup
monitoring = VLLMAdvancedMonitoring({
    "customer_service": vllm_manager,
    # Add other managers as needed
})

async def advanced_monitoring_loop():
    """Advanced monitoring with auto-scaling recommendations."""
    while True:
        try:
            # Collect metrics
            metrics = await monitoring.collect_comprehensive_metrics()
            monitoring.metrics_history.append(metrics)
            
            # Keep only last 1000 entries
            if len(monitoring.metrics_history) > 1000:
                monitoring.metrics_history = monitoring.metrics_history[-1000:]
            
            # Generate recommendations every 5 minutes
            if len(monitoring.metrics_history) % 10 == 0:  # Every 10th collection (5 minutes if collecting every 30s)
                recommendations = await monitoring.auto_scaling_recommendations()
                
                if recommendations:
                    logging.info(f"Auto-scaling recommendations: {recommendations}")
            
            # Generate performance report every hour
            if len(monitoring.metrics_history) % 120 == 0:  # Every 120th collection (1 hour)
                report = monitoring.generate_performance_report(60)
                logging.info(f"Performance report: {json.dumps(report, indent=2)}")
            
        except Exception as e:
            logging.error(f"Advanced monitoring error: {e}")
        
        await asyncio.sleep(30)  # Collect metrics every 30 seconds

# Start advanced monitoring
# asyncio.create_task(advanced_monitoring_loop())
```
  

#### Configuraci√≥n y optimizaci√≥n avanzada  

**Plantillas de configuraci√≥n de producci√≥n VLLM**:  
```python
from enum import Enum
from typing import Dict, Any

class DeploymentScenario(Enum):
    DEVELOPMENT = "development"
    STAGING = "staging"
    PRODUCTION_LOW = "production_low"
    PRODUCTION_HIGH = "production_high"
    ENTERPRISE = "enterprise"

class VLLMConfigTemplates:
    """Production-ready VLLM configuration templates."""
    
    @staticmethod
    def get_config_template(scenario: DeploymentScenario) -> Dict[str, Any]:
        """Get optimized configuration for deployment scenario."""
        
        templates = {
            DeploymentScenario.DEVELOPMENT: {
                "gpu_memory_utilization": 0.6,
                "max_model_len": 2048,
                "tensor_parallel_size": 1,
                "pipeline_parallel_size": 1,
                "quantization": None,
                "enable_prefix_caching": False,
                "max_num_seqs": 32,
                "max_num_batched_tokens": 2048
            },
            
            DeploymentScenario.STAGING: {
                "gpu_memory_utilization": 0.8,
                "max_model_len": 4096,
                "tensor_parallel_size": 1,
                "pipeline_parallel_size": 1,
                "quantization": "awq",
                "enable_prefix_caching": True,
                "max_num_seqs": 64,
                "max_num_batched_tokens": 4096
            },
            
            DeploymentScenario.PRODUCTION_LOW: {
                "gpu_memory_utilization": 0.85,
                "max_model_len": 4096,
                "tensor_parallel_size": 1,
                "pipeline_parallel_size": 1,
                "quantization": "awq",
                "enable_prefix_caching": True,
                "max_num_seqs": 128,
                "max_num_batched_tokens": 8192,
                "enable_chunked_prefill": True
            },
            
            DeploymentScenario.PRODUCTION_HIGH: {
                "gpu_memory_utilization": 0.9,
                "max_model_len": 8192,
                "tensor_parallel_size": 2,
                "pipeline_parallel_size": 1,
                "quantization": "awq",
                "enable_prefix_caching": True,
                "max_num_seqs": 256,
                "max_num_batched_tokens": 16384,
                "enable_chunked_prefill": True,
                "speculative_model": "small_draft_model"
            },
            
            DeploymentScenario.ENTERPRISE: {
                "gpu_memory_utilization": 0.95,
                "max_model_len": 16384,
                "tensor_parallel_size": 4,
                "pipeline_parallel_size": 2,
                "quantization": "awq",
                "enable_prefix_caching": True,
                "max_num_seqs": 512,
                "max_num_batched_tokens": 32768,
                "enable_chunked_prefill": True,
                "speculative_model": "optimized_draft_model",
                "guided_decoding_backend": "outlines"
            }
        }
        
        return templates[scenario]
    
    @staticmethod
    def generate_vllm_command(model_name: str, 
                             scenario: DeploymentScenario,
                             port: int = 8000,
                             host: str = "0.0.0.0") -> List[str]:
        """Generate optimized VLLM command for deployment scenario."""
        
        config = VLLMConfigTemplates.get_config_template(scenario)
        
        cmd = [
            "python", "-m", "vllm.entrypoints.openai.api_server",
            "--model", model_name,
            "--host", host,
            "--port", str(port),
            "--gpu-memory-utilization", str(config["gpu_memory_utilization"]),
            "--max-model-len", str(config["max_model_len"]),
            "--tensor-parallel-size", str(config["tensor_parallel_size"]),
            "--max-num-seqs", str(config["max_num_seqs"]),
            "--max-num-batched-tokens", str(config["max_num_batched_tokens"]),
            "--trust-remote-code",
            "--disable-log-requests"
        ]
        
        # Add optional parameters
        if config.get("quantization"):
            cmd.extend(["--quantization", config["quantization"]])
        
        if config.get("enable_prefix_caching"):
            cmd.append("--enable-prefix-caching")
        
        if config.get("enable_chunked_prefill"):
            cmd.append("--enable-chunked-prefill")
        
        if config.get("pipeline_parallel_size", 1) > 1:
            cmd.extend(["--pipeline-parallel-size", str(config["pipeline_parallel_size"])])
        
        if config.get("speculative_model"):
            cmd.extend(["--speculative-model", config["speculative_model"]])
        
        return cmd

# Usage examples
dev_cmd = VLLMConfigTemplates.generate_vllm_command(
    "microsoft/Phi-3.5-mini-instruct",
    DeploymentScenario.DEVELOPMENT,
    port=8000
)

prod_cmd = VLLMConfigTemplates.generate_vllm_command(
    "microsoft/Phi-3.5-mini-instruct",
    DeploymentScenario.PRODUCTION_HIGH,
    port=8001
)

print(f"Development command: {' '.join(dev_cmd)}")
print(f"Production command: {' '.join(prod_cmd)}")
```
  
**Lista de verificaci√≥n para implementaci√≥n de producci√≥n con VLLM**:  

‚úÖ **Optimizaci√≥n de hardware**:  
- Configurar paralelismo tensorial para configuraciones de m√∫ltiples GPU  
- Habilitar la cuantizaci√≥n (AWQ/GPTQ) para eficiencia de memoria  
- Establecer una utilizaci√≥n √≥ptima de memoria GPU (85-95%)  
- Configurar tama√±os de lote apropiados para el rendimiento  

‚úÖ **Ajuste de rendimiento**:  
- Habilitar almacenamiento en cach√© de prefijos para consultas repetidas  
- Configurar pre-relleno segmentado para secuencias largas  
- Configurar decodificaci√≥n especulativa para una inferencia m√°s r√°pida  
- Optimizar max_num_seqs seg√∫n el hardware  

‚úÖ **Caracter√≠sticas de producci√≥n**:  
- Configurar monitoreo de salud y recopilaci√≥n de m√©tricas  
- Configurar reinicio autom√°tico y conmutaci√≥n por error  
- Implementar encolamiento de solicitudes y balanceo de carga  
- Configurar registro y alertas exhaustivos  

‚úÖ **Seguridad y confiabilidad**:  
- Configurar reglas de firewall y controles de acceso  
- Configurar limitaci√≥n de tasa de API y autenticaci√≥n  
- Implementar apagado y limpieza controlados  
- Configurar copias de seguridad y recuperaci√≥n ante desastres  

‚úÖ **Pruebas de integraci√≥n**:  
- Probar la integraci√≥n del Marco de Agentes de Microsoft  
- Validar escenarios de alto rendimiento  
- Probar procedimientos de conmutaci√≥n por error y recuperaci√≥n  
- Evaluar el rendimiento bajo carga  

**Comparaci√≥n con otras soluciones**:

| Caracter√≠stica | VLLM | Foundry Local | Ollama |
|----------------|------|---------------|--------|
| **Caso de uso objetivo** | Producci√≥n de alto rendimiento | Facilidad de uso empresarial | Desarrollo y comunidad |
| **Rendimiento** | M√°ximo rendimiento | Equilibrado | Bueno |
| **Eficiencia de memoria** | Optimizaci√≥n PagedAttention | Optimizaci√≥n autom√°tica | Est√°ndar |
| **Complejidad de configuraci√≥n** | Alta (muchos par√°metros) | Baja (autom√°tica) | Baja (simple) |
| **Escalabilidad** | Excelente (tensor/paralelismo de pipeline) | Buena | Limitada |
| **Cuantizaci√≥n** | Avanzada (AWQ, GPTQ, FP8) | Autom√°tica | GGUF est√°ndar |
| **Caracter√≠sticas empresariales** | Implementaci√≥n personalizada necesaria | Integradas | Herramientas comunitarias |
| **Mejor para** | Agentes de producci√≥n a gran escala | Producci√≥n empresarial | Desarrollo |

**Cu√°ndo elegir VLLM**:  
- **Requisitos de alto rendimiento**: Procesar cientos de solicitudes por segundo  
- **Implementaciones a gran escala**: Implementaciones con m√∫ltiples GPU y nodos  
- **Cr√≠tico para el rendimiento**: Tiempos de respuesta inferiores al segundo a gran escala  
- **Optimizaci√≥n avanzada**: Necesidad de cuantizaci√≥n y agrupaci√≥n personalizadas  
- **Eficiencia de recursos**: M√°xima utilizaci√≥n de hardware GPU costoso  

## Aplicaciones reales de agentes SLM  

### Agentes SLM para atenci√≥n al cliente  
- **Capacidades SLM**: Consultas de cuentas, restablecimiento de contrase√±as, verificaci√≥n de estado de pedidos  
- **Beneficios de costos**: Reducci√≥n de costos de inferencia 10x en comparaci√≥n con agentes LLM  
- **Rendimiento**: Tiempos de respuesta m√°s r√°pidos con calidad consistente para consultas rutinarias  

### Agentes SLM para procesos empresariales  
- **Agentes de procesamiento de facturas**: Extraer datos, validar informaci√≥n, enviar para aprobaci√≥n  
- **Agentes de gesti√≥n de correos electr√≥nicos**: Categorizar, priorizar, redactar respuestas autom√°ticamente  
- **Agentes de programaci√≥n**: Coordinar reuniones, gestionar calendarios, enviar recordatorios  

### Asistentes digitales personales SLM  
- **Agentes de gesti√≥n de tareas**: Crear, actualizar, organizar listas de tareas eficientemente  
- **Agentes de recopilaci√≥n de informaci√≥n**: Investigar temas, resumir hallazgos localmente  
- **Agentes de comunicaci√≥n**: Redactar correos electr√≥nicos, mensajes, publicaciones en redes sociales de forma privada  

### Agentes SLM para comercio y finanzas  
- **Agentes de monitoreo de mercado**: Rastrear precios, identificar tendencias en tiempo real  
- **Agentes de generaci√≥n de informes**: Crear res√∫menes diarios/semanales autom√°ticamente  
- **Agentes de evaluaci√≥n de riesgos**: Evaluar posiciones de portafolio utilizando datos locales  

### Agentes SLM para soporte en salud  
- **Agentes de programaci√≥n de pacientes**: Coordinar citas, enviar recordatorios autom√°ticos  
- **Agentes de documentaci√≥n**: Generar res√∫menes m√©dicos, informes localmente  
- **Agentes de gesti√≥n de recetas**: Rastrear renovaciones, verificar interacciones de forma privada  

## Marco de Agentes de Microsoft: Desarrollo de agentes listos para producci√≥n  

### Descripci√≥n general y arquitectura  

El Marco de Agentes de Microsoft proporciona una plataforma integral de nivel empresarial para construir, implementar y gestionar agentes de IA que pueden operar tanto en la nube como en entornos de borde sin conexi√≥n. El marco est√° dise√±ado espec√≠ficamente para trabajar sin problemas con Modelos de Lenguaje Peque√±os y escenarios de computaci√≥n en el borde, lo que lo hace ideal para implementaciones sensibles a la privacidad y con recursos limitados.  

**Componentes principales del marco**:  
- **Entorno de ejecuci√≥n de agentes**: Entorno de ejecuci√≥n ligero optimizado para dispositivos de borde  
- **Sistema de integraci√≥n de herramientas**: Arquitectura de complementos extensible para conectar servicios externos y APIs  
- **Gesti√≥n de estado**: Memoria persistente del agente y manejo de contexto entre sesiones  
- **Capa de seguridad**: Controles de seguridad integrados para implementaci√≥n empresarial  
- **Motor de orquestaci√≥n**: Coordinaci√≥n de m√∫ltiples agentes y gesti√≥n de flujos de trabajo  

### Caracter√≠sticas clave para implementaci√≥n en el borde  

**Arquitectura offline-first**: El Marco de Agentes de Microsoft est√° dise√±ado con principios offline-first, permitiendo que los agentes operen eficazmente sin conectividad constante a Internet. Esto incluye inferencia de modelos locales, bases de conocimiento en cach√©, ejecuci√≥n de herramientas sin conexi√≥n y degradaci√≥n controlada cuando los servicios en la nube no est√°n disponibles.  

**Optimizaci√≥n de recursos**: El marco proporciona gesti√≥n inteligente de recursos con optimizaci√≥n autom√°tica de memoria para SLMs, balanceo de carga CPU/GPU para dispositivos de borde, selecci√≥n adaptativa de modelos basada en recursos disponibles y patrones de inferencia eficientes en consumo de energ√≠a para implementaciones m√≥viles.  

**Seguridad y privacidad**: Las caracter√≠sticas de seguridad de nivel empresarial incluyen procesamiento de datos local para mantener la privacidad, canales de comunicaci√≥n encriptados para agentes, controles de acceso basados en roles para capacidades de agentes y registro de auditor√≠a para requisitos de cumplimiento.  

### Integraci√≥n con Foundry Local  

El Marco de Agentes de Microsoft se integra perfectamente con Foundry Local para proporcionar una soluci√≥n completa de IA en el borde:  

**Descubrimiento autom√°tico de modelos**: El marco detecta y se conecta autom√°ticamente a instancias de Foundry Local, descubre modelos SLM disponibles y selecciona modelos √≥ptimos seg√∫n los requisitos del agente y las capacidades del hardware.  

**Carga din√°mica de modelos**: Los agentes pueden cargar din√°micamente diferentes SLMs para tareas espec√≠ficas, permitiendo sistemas de agentes multi-modelo donde diferentes modelos manejan diferentes tipos de solicitudes, y conmutaci√≥n autom√°tica entre modelos seg√∫n disponibilidad y rendimiento.  

**Optimizaci√≥n del rendimiento**: Los mecanismos de almacenamiento en cach√© integrados reducen los tiempos de carga de modelos, el agrupamiento de conexiones optimiza las llamadas API a Foundry Local, y el agrupamiento inteligente mejora el rendimiento para m√∫ltiples solicitudes de agentes.  

### Construcci√≥n de agentes con el Marco de Agentes de Microsoft  

#### Definici√≥n y configuraci√≥n de agentes  

```python
from microsoft_agent_framework import Agent, Tool, Config
from foundry_local import FoundryLocalManager

# Configure agent with Foundry Local integration
config = Config(
    name="customer-service-agent",
    model_provider="foundry-local",
    model_alias="phi-4-mini",
    max_tokens=512,
    temperature=0.1,
    offline_mode=True
)

# Initialize Foundry Local connection
foundry = FoundryLocalManager("phi-4-mini")

# Create agent instance
agent = Agent(
    config=config,
    model_endpoint=foundry.endpoint,
    api_key=foundry.api_key
)
```
  
#### Integraci√≥n de herramientas para escenarios en el borde  

```python
# Define tools for offline operation
@agent.tool
def lookup_customer_info(customer_id: str) -> dict:
    """Look up customer information from local database."""
    # Local database query - works offline
    return local_db.get_customer(customer_id)

@agent.tool
def create_support_ticket(issue: str, priority: str) -> str:
    """Create a support ticket in local system."""
    # Local ticket creation with sync when online
    ticket_id = local_system.create_ticket(issue, priority)
    return f"Ticket {ticket_id} created successfully"

@agent.tool
def schedule_callback(customer_id: str, preferred_time: str) -> str:
    """Schedule a callback for the customer."""
    # Local scheduling with calendar integration
    return local_calendar.schedule(customer_id, preferred_time)
```
  
#### Orquestaci√≥n de m√∫ltiples agentes  

```python
from microsoft_agent_framework import AgentOrchestrator

# Create specialized agents for different domains
scheduling_agent = Agent(
    config=Config(
        name="scheduling-agent",
        model_alias="qwen2.5-0.5b",  # Lightweight for simple tasks
        specialized_for="scheduling"
    )
)

technical_support_agent = Agent(
    config=Config(
        name="technical-agent",
        model_alias="phi-4-mini",  # More capable for complex issues
        specialized_for="technical_support"
    )
)

# Orchestrate multiple agents
orchestrator = AgentOrchestrator([
    scheduling_agent,
    technical_support_agent
])

# Route requests based on intent
result = orchestrator.process_request(
    "I need to schedule a callback for a technical issue",
    routing_strategy="intent-based"
)
```
  

### Patrones avanzados de implementaci√≥n en el borde  

#### Arquitectura jer√°rquica de agentes  

**Cl√∫steres locales de agentes**: Implementar m√∫ltiples agentes SLM especializados en dispositivos de borde, cada uno optimizado para tareas espec√≠ficas. Usar modelos ligeros como Qwen2.5-0.5B para enrutamiento y programaci√≥n simples, modelos medianos como Phi-4-Mini para atenci√≥n al cliente y documentaci√≥n, y modelos m√°s grandes para razonamiento complejo cuando los recursos lo permitan.  

**Coordinaci√≥n entre el borde y la nube**: Implementar patrones inteligentes de escalamiento donde los agentes locales manejan tareas rutinarias, los agentes en la nube proporcionan razonamiento complejo cuando la conectividad lo permite, y la transferencia fluida entre el procesamiento en el borde y la nube mantiene la continuidad.  

#### Configuraciones de implementaci√≥n  

**Implementaci√≥n en un solo dispositivo**:  
```yaml
deployment:
  type: single-device
  hardware: edge-device
  models:
    - alias: "phi-4-mini"
      primary: true
      tasks: ["conversation", "reasoning"]
    - alias: "qwen2.5-0.5b"
      secondary: true
      tasks: ["routing", "classification"]
  agents:
    - name: "primary-agent"
      model: "phi-4-mini"
      tools: ["database", "calendar", "email"]
```
  
**Implementaci√≥n distribuida en el borde**:  
```yaml
deployment:
  type: distributed-edge
  nodes:
    - id: "edge-1"
      agents: ["customer-service", "scheduling"]
      models: ["phi-4-mini"]
    - id: "edge-2"
      agents: ["technical-support", "documentation"]
      models: ["qwen2.5-coder-0.5b"]
  coordination:
    load_balancing: true
    failover: automatic
```
  

### Optimizaci√≥n del rendimiento para agentes en el borde  

#### Estrategias de selecci√≥n de modelos  

**Asignaci√≥n de modelos basada en tareas**: El Marco de Agentes de Microsoft permite la selecci√≥n inteligente de modelos basada en la complejidad de la tarea y los requisitos:  

- **Tareas simples** (preguntas y respuestas, enrutamiento): Qwen2.5-0.5B (500MB, <100ms de respuesta)  
- **Tareas moderadas** (atenci√≥n al cliente, programaci√≥n): Phi-4-Mini (2.4GB, 200-500ms de respuesta)  
- **Tareas complejas** (an√°lisis t√©cnico, planificaci√≥n): Phi-4 (7GB, 1-3s de respuesta cuando los recursos lo permiten)  

**Cambio din√°mico de modelos**: Los agentes pueden cambiar entre modelos seg√∫n la carga actual del sistema, evaluaci√≥n de la complejidad de la tarea, niveles de prioridad del usuario y recursos de hardware disponibles.  

#### Gesti√≥n de memoria y recursos  

```python
# Configure resource constraints for edge deployment
resource_config = ResourceConfig(
    max_memory_usage="4GB",
    max_concurrent_agents=3,
    model_cache_size="2GB",
    auto_unload_idle_models=True,
    power_management=True
)

agent = Agent(
    config=config,
    resource_limits=resource_config
)
```
  

### Patrones de integraci√≥n empresarial  

#### Seguridad y cumplimiento  

**Procesamiento de datos local**: Todo el procesamiento de agentes ocurre localmente, asegurando que los datos sensibles nunca salgan del dispositivo de borde. Esto incluye protecci√≥n de informaci√≥n del cliente, cumplimiento de HIPAA para agentes de salud, seguridad de datos financieros para agentes bancarios y cumplimiento de GDPR para implementaciones en Europa.  

**Control de acceso**: Permisos basados en roles controlan qu√© herramientas pueden acceder los agentes, autenticaci√≥n de usuarios para interacciones con agentes y registros de auditor√≠a para todas las acciones y decisiones de los agentes.  

#### Monitoreo y observabilidad  

```python
from microsoft_agent_framework import AgentMonitor

# Set up monitoring for edge agents
monitor = AgentMonitor(
    metrics=["response_time", "success_rate", "resource_usage"],
    alerts=[
        {"metric": "response_time", "threshold": "2s", "action": "scale_down_model"},
        {"metric": "memory_usage", "threshold": "80%", "action": "unload_idle_agents"}
    ],
    local_storage=True  # Store metrics locally for offline operation
)

agent.add_monitor(monitor)
```
  

### Ejemplos de implementaci√≥n en el mundo real  

#### Sistema de agentes en el borde para retail  

```python
# Retail kiosk agent for in-store customer assistance
retail_agent = Agent(
    config=Config(
        name="retail-assistant",
        model_alias="phi-4-mini",
        context="You are a helpful retail assistant in an electronics store."
    )
)

@retail_agent.tool
def check_inventory(product_sku: str) -> dict:
    """Check local inventory for a product."""
    return local_inventory.lookup(product_sku)

@retail_agent.tool
def find_alternatives(product_category: str) -> list:
    """Find alternative products in the same category."""
    return local_catalog.find_similar(product_category)

@retail_agent.tool
def create_price_quote(items: list) -> dict:
    """Generate a price quote for multiple items."""
    return pricing_engine.calculate_quote(items)
```
  
#### Agente de soporte en salud  

```python
# HIPAA-compliant patient support agent
healthcare_agent = Agent(
    config=Config(
        name="patient-support",
        model_alias="phi-4-mini",
        privacy_mode=True,  # Enhanced privacy for healthcare
        compliance=["HIPAA"]
    )
)

@healthcare_agent.tool
def check_appointment_availability(provider_id: str, date_range: str) -> list:
    """Check appointment slots with healthcare provider."""
    return local_scheduling.get_availability(provider_id, date_range)

@healthcare_agent.tool
def access_patient_portal(patient_id: str, auth_token: str) -> dict:
    """Secure access to patient information."""
    if security.validate_token(auth_token):
        return patient_portal.get_summary(patient_id)
    return {"error": "Authentication failed"}
```
  

### Mejores pr√°cticas para el Marco de Agentes de Microsoft  

#### Directrices de desarrollo  

1. **Comenzar simple**: Iniciar con escenarios de un solo agente antes de construir sistemas complejos de m√∫ltiples agentes  
2. **Dimensionamiento adecuado del modelo**: Elegir el modelo m√°s peque√±o que cumpla con los requisitos de precisi√≥n  
3. **Dise√±o de herramientas**: Crear herramientas enfocadas y de prop√≥sito √∫nico en lugar de herramientas multifunci√≥n complejas  
4. **Manejo de errores**: Implementar degradaci√≥n controlada para escenarios sin conexi√≥n y fallos de modelos  
5. **Pruebas**: Probar extensivamente los agentes en condiciones sin conexi√≥n y entornos con recursos limitados  

#### Mejores pr√°cticas de implementaci√≥n  

1. **Despliegue gradual**: Implementar inicialmente en peque√±os grupos de usuarios, monitorear m√©tricas de rendimiento de cerca  
2. **Monitoreo de recursos**: Configurar alertas para umbrales de memoria, CPU y tiempos de respuesta  
3. **Estrategias de respaldo**: Tener siempre planes de respaldo para fallos de modelos o agotamiento de recursos  
4. **Seguridad primero**: Implementar controles de seguridad desde el principio, no como una idea tard√≠a  
5. **Documentaci√≥n**: Mantener documentaci√≥n clara de las capacidades y limitaciones de los agentes  

### Hoja de ruta futura e integraci√≥n  

El Marco de Agentes de Microsoft contin√∫a evolucionando con optimizaci√≥n mejorada para SLMs, herramientas de implementaci√≥n en el borde mejoradas, mejor gesti√≥n de recursos para entornos limitados y un ecosistema de herramientas ampliado para escenarios empresariales comunes.  

**Caracter√≠sticas pr√≥ximas**:  
- **AutoML para optimizaci√≥n de agentes**: Ajuste autom√°tico de SLMs para tareas espec√≠ficas de agentes  
- **Redes de malla en el borde**: Coordinaci√≥n entre m√∫ltiples implementaciones de agentes en el borde  
- **Telemetr√≠a avanzada**: Monitoreo y an√°lisis mejorados para el rendimiento de agentes  
- **Constructor visual de agentes**: Herramientas de desarrollo de agentes de bajo c√≥digo/sin c√≥digo  

## Mejores pr√°cticas para la implementaci√≥n de agentes SLM  

### Directrices de selecci√≥n de SLM para agentes  

Al seleccionar SLMs para la implementaci√≥n de agentes, considere los siguientes factores:  

**Consideraciones sobre el tama√±o del modelo**: Elegir modelos ultra comprimidos como Q2_K para aplicaciones de agentes m√≥viles extremas, modelos equilibrados como Q4_K_M para escenarios generales de agentes, y modelos de mayor precisi√≥n como Q8_0 para aplicaciones de agentes donde la calidad es cr√≠tica.  

**Alineaci√≥n con el caso de uso del agente**: Ajustar las capacidades de SLM a los requisitos espec√≠ficos del agente, considerando factores como la preservaci√≥n de la precisi√≥n para decisiones del agente, velocidad de inferencia para interacciones en tiempo real, limitaciones de memoria para implementaci√≥n en el borde y requisitos de operaci√≥n sin conexi√≥n para agentes enfocados en la privacidad.  

### Selecci√≥n de estrategias de optimizaci√≥n para agentes SLM  

**Enfoque de cuantizaci√≥n para agentes**: Seleccionar niveles de cuantizaci√≥n apropiados seg√∫n los requisitos de calidad del agente y las limitaciones de hardware. Considerar Q4_0 para m√°xima compresi√≥n en agentes m√≥viles, Q5_1 para calidad-compresi√≥n equilibrada en agentes generales, y Q8_0 para calidad casi original en aplicaciones cr√≠ticas de agentes.  
**Selecci√≥n de Framework para el Despliegue de Agentes**: Elige frameworks de optimizaci√≥n seg√∫n el hardware objetivo y los requisitos del agente. Utiliza Llama.cpp para el despliegue de agentes optimizados para CPU, Apple MLX para aplicaciones de agentes en Apple Silicon y ONNX para compatibilidad de agentes multiplataforma.

## Conversi√≥n Pr√°ctica de Agentes SLM y Casos de Uso

### Escenarios de Despliegue de Agentes en el Mundo Real

**Aplicaciones de Agentes M√≥viles**: Los formatos Q4_K destacan en aplicaciones de agentes para smartphones con un consumo m√≠nimo de memoria, mientras que Q8_0 ofrece un rendimiento equilibrado para sistemas de agentes en tablets. Los formatos Q5_K brindan una calidad superior para agentes de productividad m√≥vil.

**Computaci√≥n de Agentes en Escritorio y Edge**: Q5_K proporciona un rendimiento √≥ptimo para aplicaciones de agentes en escritorio, Q8_0 ofrece inferencia de alta calidad para entornos de estaciones de trabajo, y Q4_K permite un procesamiento eficiente en dispositivos edge.

**Agentes de Investigaci√≥n y Experimentales**: Los formatos avanzados de cuantizaci√≥n permiten explorar inferencias de agentes con precisi√≥n ultra baja para investigaciones acad√©micas y aplicaciones de prueba de concepto que requieren recursos extremadamente limitados.

### Benchmarks de Rendimiento de Agentes SLM

**Velocidad de Inferencia de Agentes**: Q4_K logra los tiempos de respuesta m√°s r√°pidos en CPUs m√≥viles, Q5_K ofrece una relaci√≥n equilibrada entre velocidad y calidad para aplicaciones generales de agentes, Q8_0 brinda una calidad superior para tareas complejas de agentes, y los formatos experimentales maximizan el rendimiento en hardware especializado para agentes.

**Requisitos de Memoria de Agentes**: Los niveles de cuantizaci√≥n para agentes van desde Q2_K (menos de 500MB para modelos peque√±os de agentes) hasta Q8_0 (aproximadamente el 50% del tama√±o original), con configuraciones experimentales logrando la m√°xima compresi√≥n para entornos de agentes con recursos limitados.

## Desaf√≠os y Consideraciones para Agentes SLM

### Compromisos de Rendimiento en Sistemas de Agentes

El despliegue de agentes SLM implica una cuidadosa consideraci√≥n de los compromisos entre el tama√±o del modelo, la velocidad de respuesta del agente y la calidad del resultado. Mientras que Q4_K ofrece una velocidad y eficiencia excepcionales para agentes m√≥viles, Q8_0 proporciona una calidad superior para tareas complejas de agentes. Q5_K encuentra un punto intermedio adecuado para la mayor√≠a de las aplicaciones generales de agentes.

### Compatibilidad de Hardware para Agentes SLM

Los diferentes dispositivos edge tienen capacidades variables para el despliegue de agentes SLM. Q4_K funciona eficientemente en procesadores b√°sicos para agentes simples, Q5_K requiere recursos computacionales moderados para un rendimiento equilibrado de agentes, y Q8_0 se beneficia de hardware de gama alta para capacidades avanzadas de agentes.

### Seguridad y Privacidad en Sistemas de Agentes SLM

Aunque los agentes SLM permiten el procesamiento local para mejorar la privacidad, se deben implementar medidas de seguridad adecuadas para proteger los modelos de agentes y los datos en entornos edge. Esto es especialmente importante al desplegar formatos de agentes de alta precisi√≥n en entornos empresariales o formatos comprimidos de agentes en aplicaciones que manejan datos sensibles.

## Tendencias Futuras en el Desarrollo de Agentes SLM

El panorama de los agentes SLM sigue evolucionando con avances en t√©cnicas de compresi√≥n, m√©todos de optimizaci√≥n y estrategias de despliegue en edge. Los desarrollos futuros incluyen algoritmos de cuantizaci√≥n m√°s eficientes para modelos de agentes, m√©todos de compresi√≥n mejorados para flujos de trabajo de agentes y una mejor integraci√≥n con aceleradores de hardware edge para el procesamiento de agentes.

**Predicciones de Mercado para Agentes SLM**: Seg√∫n investigaciones recientes, la automatizaci√≥n impulsada por agentes podr√≠a eliminar entre el 40% y el 60% de las tareas cognitivas repetitivas en flujos de trabajo empresariales para 2027, con los SLM liderando esta transformaci√≥n debido a su eficiencia en costos y flexibilidad de despliegue.

**Tendencias Tecnol√≥gicas en Agentes SLM**:
- **Agentes SLM Especializados**: Modelos espec√≠ficos para tareas particulares de agentes e industrias
- **Computaci√≥n de Agentes en Edge**: Capacidades mejoradas de agentes en dispositivos con mayor privacidad y menor latencia
- **Orquestaci√≥n de Agentes**: Mejor coordinaci√≥n entre m√∫ltiples agentes SLM con enrutamiento din√°mico y balanceo de carga
- **Democratizaci√≥n**: La flexibilidad de los SLM permite una participaci√≥n m√°s amplia en el desarrollo de agentes en las organizaciones

## C√≥mo Empezar con los Agentes SLM

### Paso 1: Configurar el Entorno del Framework de Agentes de Microsoft

**Instalar Dependencias**:
```bash
# Install Microsoft Agent Framework
pip install microsoft-agent-framework

# Install Foundry Local SDK for edge deployment
pip install foundry-local-sdk

# Install additional dependencies for edge agents
pip install openai asyncio
```

**Inicializar Foundry Local**:
```bash
# Start Foundry Local service
foundry service start

# Load default model for agent development
foundry model run phi-4-mini
```

### Paso 2: Elegir tu SLM para Aplicaciones de Agentes
Opciones populares para el Framework de Agentes de Microsoft:
- **Microsoft Phi-4 Mini (3.8B)**: Excelente para tareas generales de agentes con rendimiento equilibrado
- **Qwen2.5-0.5B (0.5B)**: Ultra eficiente para agentes simples de enrutamiento y clasificaci√≥n
- **Qwen2.5-Coder-0.5B (0.5B)**: Especializado para tareas de agentes relacionadas con c√≥digo
- **Phi-4 (7B)**: Razonamiento avanzado para escenarios edge complejos cuando los recursos lo permiten

### Paso 3: Crear tu Primer Agente con el Framework de Agentes de Microsoft

**Configuraci√≥n B√°sica del Agente**:
```python
from microsoft_agent_framework import Agent, Config
from foundry_local import FoundryLocalManager

# Initialize Foundry Local connection
foundry = FoundryLocalManager("phi-4-mini")

# Create agent configuration
config = Config(
    name="my-first-agent",
    model_provider="foundry-local",
    model_alias="phi-4-mini",
    offline_mode=True
)

# Create and configure agent
agent = Agent(
    config=config,
    model_endpoint=foundry.endpoint,
    api_key=foundry.api_key
)

# Define a simple tool
@agent.tool
def get_current_time() -> str:
    """Get the current time."""
    from datetime import datetime
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

# Test the agent
response = agent.chat("What time is it?")
print(response)
```

### Paso 4: Definir el Alcance y los Requisitos del Agente
Comienza con aplicaciones de agentes enfocadas y bien definidas utilizando el Framework de Agentes de Microsoft:
- **Agentes de dominio √∫nico**: Servicio al cliente O programaci√≥n de horarios O investigaci√≥n
- **Objetivos claros del agente**: Metas espec√≠ficas y medibles para el rendimiento del agente
- **Integraci√≥n limitada de herramientas**: M√°ximo de 3-5 herramientas para el despliegue inicial del agente
- **L√≠mites definidos del agente**: Rutas claras de escalamiento para escenarios complejos
- **Dise√±o centrado en edge**: Prioriza la funcionalidad offline y el procesamiento local

### Paso 5: Implementar el Despliegue en Edge con el Framework de Agentes de Microsoft

**Configuraci√≥n de Recursos**:
```python
from microsoft_agent_framework import ResourceConfig

# Configure for edge deployment
resource_config = ResourceConfig(
    max_memory_usage="2GB",
    max_concurrent_agents=2,
    model_cache_size="1GB",
    auto_unload_idle_models=True,
    power_management=True
)

agent = Agent(
    config=config,
    resource_limits=resource_config
)
```

**Implementar Medidas de Seguridad para Agentes en Edge**:
- **Validaci√≥n local de entradas**: Verifica solicitudes sin depender de la nube
- **Filtrado de salidas offline**: Asegura que las respuestas cumplan con est√°ndares de calidad localmente
- **Controles de seguridad en edge**: Implementa seguridad sin requerir conectividad a internet
- **Monitoreo local**: Rastrea el rendimiento y detecta problemas utilizando telemetr√≠a en edge

### Paso 6: Medir y Optimizar el Rendimiento de Agentes en Edge
- **Tasas de finalizaci√≥n de tareas del agente**: Monitorea tasas de √©xito en escenarios offline
- **Tiempos de respuesta del agente**: Asegura tiempos de respuesta inferiores a un segundo para despliegues en edge
- **Utilizaci√≥n de recursos**: Rastrea el uso de memoria, CPU y bater√≠a en dispositivos edge
- **Eficiencia de costos**: Compara los costos de despliegue en edge con alternativas basadas en la nube
- **Fiabilidad offline**: Mide el rendimiento del agente durante interrupciones de red

## Puntos Clave para la Implementaci√≥n de Agentes SLM

1. **Los SLM son suficientes para agentes**: Para la mayor√≠a de las tareas de agentes, los modelos peque√±os funcionan tan bien como los grandes, ofreciendo ventajas significativas
2. **Eficiencia de costos en agentes**: 10-30 veces m√°s barato ejecutar agentes SLM, haci√©ndolos econ√≥micamente viables para despliegues generalizados
3. **La especializaci√≥n funciona para agentes**: Los SLM ajustados suelen superar a los LLM generales en aplicaciones espec√≠ficas de agentes
4. **Arquitectura h√≠brida de agentes**: Usa SLM para tareas rutinarias de agentes, LLM para razonamiento complejo cuando sea necesario
5. **El Framework de Agentes de Microsoft permite despliegues en producci√≥n**: Proporciona herramientas de nivel empresarial para construir, desplegar y gestionar agentes en edge
6. **Principios de dise√±o centrados en edge**: Agentes capaces de funcionar offline con procesamiento local aseguran privacidad y fiabilidad
7. **Integraci√≥n de Foundry Local**: Conexi√≥n fluida entre el Framework de Agentes de Microsoft y la inferencia de modelos locales
8. **El futuro son los agentes SLM**: Los modelos de lenguaje peque√±os con frameworks de producci√≥n son el futuro de la IA agentiva, permitiendo despliegues de agentes democratizados y eficientes

## Referencias y Lecturas Adicionales

### Art√≠culos de Investigaci√≥n y Publicaciones Fundamentales

#### Agentes de IA y Sistemas Agentivos
- **"Language Agents as Optimizable Graphs"** (2024) - Investigaci√≥n fundamental sobre arquitectura y optimizaci√≥n de agentes
  - Autores: Wenyue Hua, Lishan Yang, et al.
  - Enlace: https://arxiv.org/abs/2402.16823
  - Ideas Clave: Dise√±o de agentes basado en grafos y estrategias de optimizaci√≥n

- **"The Rise and Potential of Large Language Model Based Agents"** (2023)
  - Autores: Zhiheng Xi, Wenxiang Chen, et al.
  - Enlace: https://arxiv.org/abs/2309.07864
  - Ideas Clave: Encuesta exhaustiva sobre capacidades y aplicaciones de agentes basados en LLM

- **"Cognitive Architectures for Language Agents"** (2024)
  - Autores: Theodore Sumers, Shunyu Yao, et al.
  - Enlace: https://arxiv.org/abs/2309.02427
  - Ideas Clave: Marcos cognitivos para dise√±ar agentes inteligentes

#### Modelos de Lenguaje Peque√±os y Optimizaci√≥n
- **"Phi-3 Technical Report: A Highly Capable Language Model Locally on Your Phone"** (2024)
  - Autores: Equipo de Investigaci√≥n de Microsoft
  - Enlace: https://arxiv.org/abs/2404.14219
  - Ideas Clave: Principios de dise√±o de SLM y estrategias de despliegue m√≥vil

- **"Qwen2.5 Technical Report"** (2024)
  - Autores: Equipo de Alibaba Cloud
  - Enlace: https://arxiv.org/abs/2407.10671
  - Ideas Clave: T√©cnicas avanzadas de entrenamiento de SLM y optimizaci√≥n de rendimiento

- **"TinyLlama: An Open-Source Small Language Model"** (2024)
  - Autores: Peiyuan Zhang, Guangtao Zeng, et al.
  - Enlace: https://arxiv.org/abs/2401.02385
  - Ideas Clave: Dise√±o ultra compacto de modelos y eficiencia en entrenamiento

### Documentaci√≥n Oficial y Frameworks

#### Framework de Agentes de Microsoft
- **Documentaci√≥n Oficial**: https://docs.microsoft.com/en-us/azure/ai-services/agents/
- **Repositorio GitHub**: https://github.com/microsoft/agent-framework

#### Foundry Local
- **Repositorio Principal**: https://github.com/microsoft/foundry-local
- **Documentaci√≥n**: https://github.com/microsoft/foundry-local/blob/main/docs/README.md


#### VLLM
- **Repositorio Principal**: https://github.com/vllm-project/vllm
- **Documentaci√≥n**: https://docs.vllm.ai/


#### Ollama
- **Sitio Web Oficial**: https://ollama.ai/
- **Repositorio GitHub**: https://github.com/ollama/ollama

### Frameworks de Optimizaci√≥n de Modelos

#### Llama.cpp
- **Repositorio**: https://github.com/ggml-org/llama.cpp


#### Microsoft Olive
- **Documentaci√≥n**: https://microsoft.github.io/Olive/
- **Repositorio GitHub**: https://github.com/microsoft/Olive

#### OpenVINO
- **Sitio Oficial**: https://docs.openvino.ai/

#### Apple MLX
- **Repositorio**: https://github.com/ml-explore/mlx

### Informes de la Industria y An√°lisis de Mercado

#### Investigaci√≥n de Mercado de Agentes de IA
- **"The State of AI Agents 2025"** - McKinsey Global Institute
  - Enlace: https://www.mckinsey.com/capabilities/mckinsey-digital/our-insights/ai-agents-2025
  - Ideas Clave: Tendencias de mercado y patrones de adopci√≥n empresarial

#### Benchmarks T√©cnicos

- **"Edge AI Inference Benchmarks"** - MLPerf
  - Enlace: https://mlcommons.org/en/inference-edge/
  - Ideas Clave: M√©tricas de rendimiento estandarizadas para despliegue en edge

### Est√°ndares y Especificaciones

#### Formatos de Modelos y Est√°ndares
- **ONNX (Open Neural Network Exchange)**: https://onnx.ai/
  - Formato de modelo multiplataforma para interoperabilidad
- **Especificaci√≥n GGUF**: https://github.com/ggerganov/ggml/blob/master/docs/gguf.md
  - Formato de modelo cuantizado para inferencia en CPU
- **Especificaci√≥n API de OpenAI**: https://platform.openai.com/docs/api-reference
  - Formato est√°ndar de API para integraci√≥n de modelos de lenguaje

#### Seguridad y Cumplimiento
- **Marco de Gesti√≥n de Riesgos de IA de NIST**: https://www.nist.gov/itl/ai-risk-management-framework
- **ISO/IEC 23053:2022 - Sistemas de IA**: Marco para sistemas de IA y seguridad
- **Est√°ndares IEEE para IA**: https://standards.ieee.org/industry-connections/ai/

El cambio hacia agentes impulsados por SLM representa una transformaci√≥n fundamental en c√≥mo abordamos el despliegue de IA. El Framework de Agentes de Microsoft, combinado con plataformas locales y Modelos de Lenguaje Peque√±os eficientes, proporciona una soluci√≥n completa para construir agentes listos para producci√≥n que operan eficazmente en entornos edge. Al centrarse en la eficiencia, especializaci√≥n y utilidad pr√°ctica, esta pila tecnol√≥gica hace que los agentes de IA sean m√°s accesibles, asequibles y efectivos para aplicaciones del mundo real en todas las industrias y entornos de computaci√≥n edge.

A medida que avanzamos hacia 2025, la combinaci√≥n de modelos peque√±os cada vez m√°s capaces, frameworks sofisticados como el Framework de Agentes de Microsoft y plataformas robustas de despliegue en edge desbloquear√°n nuevas posibilidades para sistemas aut√≥nomos que pueden operar eficientemente en dispositivos edge mientras mantienen la privacidad, reducen costos y ofrecen experiencias excepcionales a los usuarios.

**Pr√≥ximos Pasos para la Implementaci√≥n**:
1. **Explorar Llamadas a Funciones**: Aprende c√≥mo los SLM manejan la integraci√≥n de herramientas y salidas estructuradas
2. **Dominar el Protocolo de Contexto de Modelos (MCP)**: Comprende patrones avanzados de comunicaci√≥n de agentes
3. **Construir Agentes de Producci√≥n**: Usa el Framework de Agentes de Microsoft para despliegues de nivel empresarial
4. **Optimizar para Edge**: Aplica t√©cnicas avanzadas de optimizaci√≥n para entornos con recursos limitados


## ‚û°Ô∏è ¬øQu√© sigue?

- [02: Llamadas a Funciones en Modelos de Lenguaje Peque√±os (SLMs)](./02.FunctionCalling.md)

---

**Descargo de responsabilidad**:  
Este documento ha sido traducido utilizando el servicio de traducci√≥n autom√°tica [Co-op Translator](https://github.com/Azure/co-op-translator). Aunque nos esforzamos por lograr precisi√≥n, tenga en cuenta que las traducciones autom√°ticas pueden contener errores o imprecisiones. El documento original en su idioma nativo debe considerarse como la fuente autorizada. Para informaci√≥n cr√≠tica, se recomienda una traducci√≥n profesional realizada por humanos. No nos hacemos responsables de malentendidos o interpretaciones err√≥neas que puedan surgir del uso de esta traducci√≥n.